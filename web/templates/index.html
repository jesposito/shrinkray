<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shrinkray</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="icon" type="image/png" href="/favicon.png">
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #FAFAFA;
            --bg-secondary: #FFFFFF;
            --bg-tertiary: #F5F5F5;
            --text-primary: #1A1A1A;
            --text-secondary: #6B6B6B;
            --text-tertiary: #9A9A9A;
            --accent: #2563EB;
            --accent-hover: #1D4ED8;
            --accent-light: #EFF6FF;
            --success: #059669;
            --success-light: #ECFDF5;
            --warning: #D97706;
            --warning-light: #FFFBEB;
            --error: #DC2626;
            --error-light: #FEF2F2;
            --border: #E5E5E5;
            --border-hover: #D4D4D4;
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
            --shadow-lg: 0 12px 32px rgba(0,0,0,0.12);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            --font-sans: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
            --transition-fast: 150ms ease;
            --transition-normal: 250ms ease;
        }

        /* Dark theme */
        [data-theme="dark"] {
            --bg-primary: #0F0F0F;
            --bg-secondary: #1A1A1A;
            --bg-tertiary: #252525;
            --text-primary: #F5F5F5;
            --text-secondary: #A0A0A0;
            --text-tertiary: #6B6B6B;
            --accent: #3B82F6;
            --accent-hover: #60A5FA;
            --accent-light: #1E3A5F;
            --success: #10B981;
            --success-light: #064E3B;
            --warning: #F59E0B;
            --warning-light: #78350F;
            --error: #EF4444;
            --error-light: #7F1D1D;
            --border: #2E2E2E;
            --border-hover: #404040;
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.2);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.3);
            --shadow-lg: 0 12px 32px rgba(0,0,0,0.4);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: var(--font-sans);
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
        }

        /* Layout */
        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 0 24px;
            height: 64px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 1.125rem;
            letter-spacing: -0.02em;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            border-radius: var(--radius-sm);
            overflow: hidden;
        }

        .logo-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .stats-bar {
            display: flex;
            gap: 24px;
            margin-left: 40px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-value {
            font-weight: 600;
            font-size: 0.9375rem;
            font-variant-numeric: tabular-nums;
        }

        .stat-label {
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        .stat-item.success .stat-value { color: var(--success); }
        .stat-item.running .stat-value { color: var(--accent); }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .menu-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transition: all var(--transition-fast);
        }

        .menu-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .menu-btn svg {
            width: 20px;
            height: 20px;
        }

        /* Theme toggle icons */
        .theme-icon-light {
            display: none;
        }
        .theme-icon-dark {
            display: block;
        }
        [data-theme="dark"] .theme-icon-light {
            display: block;
        }
        [data-theme="dark"] .theme-icon-dark {
            display: none;
        }

        .main {
            flex: 1;
            display: flex;
            align-items: flex-start;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
            padding: 24px;
            gap: 24px;
            min-height: 0;
            overflow: hidden;
        }

        /* Browser Panel */
        .browser-panel {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .panel {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border);
            overflow: hidden;
        }

        /* File browser panel - sizes to content */
        .browser-panel > .panel {
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 112px);
        }

        .panel-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .panel-title {
            font-weight: 600;
            font-size: 0.9375rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-toggle {
            background: none;
            border: 0;
            padding: 0;
            color: inherit;
            cursor: pointer;
            width: 100%;
            font: inherit;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .panel-toggle:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
            border-radius: 6px;
        }

        .panel-collapse-toggle {
            transition: transform var(--transition-fast);
        }

        .panel-toggle-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .panel.collapsed .panel-collapse-toggle {
            transform: rotate(-90deg);
        }

        .panel.collapsed .panel-body {
            display: none;
        }

        .file-list-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 10px 20px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.875rem;
            color: var(--text-secondary);
            overflow: hidden;
            white-space: nowrap;
            flex: 1 1 auto;
            min-width: 200px;
        }

        .breadcrumb a {
            color: var(--accent);
            text-decoration: none;
            transition: color var(--transition-fast);
        }

        .breadcrumb a:hover {
            color: var(--accent-hover);
        }

        .breadcrumb-sep {
            color: var(--text-tertiary);
            margin: 0 4px;
        }

        .breadcrumb-current {
            color: var(--text-primary);
            font-weight: 500;
        }

        .file-list {
            list-style: none;
            overflow-y: auto;
        }

        .file-list-header {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            font-size: 0.8125rem;
            color: var(--text-secondary);
            gap: 12px;
            flex-shrink: 0;
        }

        .file-list-header label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
        }

        .file-list-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            padding: 0;
            border-bottom: none;
            background: transparent;
            flex-shrink: 0;
            margin-left: auto;
            justify-content: flex-end;
        }

        .file-list-controls label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        .file-list-controls select {
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            padding: 6px 10px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 0.8125rem;
            font-family: var(--font-sans);
            min-width: 150px;
        }

        .file-list-controls .toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        .file-list-controls .toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent);
            cursor: pointer;
        }

        .file-item {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background var(--transition-fast);
            gap: 12px;
        }

        .file-item:hover {
            background: var(--bg-tertiary);
        }

        .file-item:last-child {
            border-bottom: none;
        }

        .file-item.selected {
            background: var(--accent-light);
        }

        .file-item.selected:hover {
            background: #DBEAFE;
        }
        [data-theme="dark"] .file-item.selected:hover {
            background: #1E40AF;
        }

        .file-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent);
            flex-shrink: 0;
        }

        .file-icon {
            width: 36px;
            height: 36px;
            border-radius: var(--radius-sm);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 1rem;
        }

        .file-icon.folder {
            background: #FEF3C7;
            color: #D97706;
        }
        [data-theme="dark"] .file-icon.folder {
            background: #78350F;
            color: #FBBF24;
        }

        .file-icon.video {
            background: var(--accent-light);
            color: var(--accent);
        }

        .file-icon.other {
            background: var(--bg-tertiary);
            color: var(--text-tertiary);
        }

        .file-info {
            flex: 1;
            min-width: 0;
        }

        .file-name {
            font-weight: 500;
            font-size: 0.9375rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-meta {
            font-size: 0.8125rem;
            color: var(--text-secondary);
            margin-top: 2px;
            display: flex;
            gap: 12px;
        }

        .file-size {
            font-variant-numeric: tabular-nums;
            color: var(--text-tertiary);
            font-size: 0.8125rem;
            flex-shrink: 0;
        }

        .codec-badge {
            display: inline-flex;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        .codec-badge.hevc,
        .codec-badge.av1 {
            background: var(--success-light);
            color: var(--success);
        }

        .codec-badge.h264 {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .file-trailing {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .processed-tag {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 0.6875rem;
            font-weight: 700;
            letter-spacing: 0.02em;
            text-transform: uppercase;
            background: rgba(16, 185, 129, 0.2);
            color: #047857;
        }

        [data-theme="dark"] .processed-tag {
            background: rgba(16, 185, 129, 0.25);
            color: #6ee7b7;
        }

        .file-list-empty {
            padding: 60px 20px;
            text-align: center;
            color: var(--text-secondary);
        }

        /* Actions Bar */
        .actions-bar {
            display: flex;
            gap: 12px;
            padding: 16px 20px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border);
            align-items: center;
            flex-shrink: 0;
        }

        .subfolder-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.875rem;
            color: var(--text-secondary);
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }

        .subfolder-toggle:hover {
            color: var(--text-primary);
        }

        .subfolder-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--accent);
        }

        .preset-select {
            padding: 10px 14px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-family: var(--font-sans);
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            min-width: 200px;
            transition: border-color var(--transition-fast);
        }

        .preset-select:hover {
            border-color: var(--border-hover);
        }

        .preset-select:focus {
            outline: none;
            border-color: var(--accent);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 18px;
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-weight: 500;
            font-family: var(--font-sans);
            cursor: pointer;
            border: none;
            transition: all var(--transition-fast);
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-primary:disabled {
            background: var(--border);
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-hover);
        }

        .btn-danger {
            background: var(--error);
            color: white;
        }

        .btn-danger:hover {
            background: #B91C1C;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 0.8125rem;
        }

        .file-action-btn {
            padding: 4px 8px;
            font-size: 0.6875rem;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        .selection-count {
            margin-left: auto;
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        /* Queue Panel */
        .queue-panel {
            width: 400px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-height: calc(100vh - 112px); /* viewport - header - padding */
        }

        .queue-panel-inner {
            display: flex;
            flex-direction: column;
            max-height: 100%;
            flex: 1;
        }

        .panel-body {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .queue-panel-content {
            flex: 1;
            min-height: 0;
        }

        .panel-body {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .queue-panel-content {
            flex: 1;
            min-height: 0;
        }

        .queue-list {
            overflow-y: auto;
        }

        .queue-panel-content .queue-list {
            flex: 1;
        }

        /* Active Jobs Panel - Separate box above queue */
        .active-jobs-panel {
            flex-shrink: 0;
        }

        .active-panel-content {
            max-height: 400px;
            overflow-y: auto;
        }

        .active-panel-section {
            padding: 12px 20px;
        }

        .active-panel-section + .active-panel-section {
            border-top: 1px solid var(--border);
        }

        .active-panel-title {
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-tertiary);
            margin-bottom: 12px;
        }

        .active-panel-empty {
            font-size: 0.8125rem;
            color: var(--text-tertiary);
            font-style: italic;
        }

        /* Job items inside active panel don't need bottom border on last item */
        .active-panel-section .job-item {
            padding: 12px 0;
        }

        .active-panel-section .job-item:first-child {
            padding-top: 0;
        }

        .active-panel-section .job-item:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .job-item {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
        }

        .job-item:last-child {
            border-bottom: none;
        }

        .job-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 8px;
        }

        .job-name {
            font-weight: 500;
            font-size: 0.9375rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
            min-width: 0;
        }

        .job-badges {
            display: flex;
            gap: 6px;
            flex-shrink: 0;
        }

        .job-badge {
            display: inline-flex;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.02em;
        }

        .job-badge.pending {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .job-badge.running {
            background: var(--accent-light);
            color: var(--accent);
        }

        .job-badge.complete {
            background: var(--success-light);
            color: var(--success);
        }

        .job-badge.failed {
            background: var(--error-light);
            color: var(--error);
        }

        .job-badge.initializing {
            background: #F3E8FF;
            color: #7C3AED;
        }
        [data-theme="dark"] .job-badge.initializing {
            background: #4C1D95;
            color: #C4B5FD;
        }

        .job-badge.hardware {
            background: var(--success-light);
            color: var(--success);
        }

        .job-badge.software {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }

        .job-badge.retry {
            background: #FEF3C7;
            color: #D97706;
        }
        [data-theme="dark"] .job-badge.retry {
            background: #78350F;
            color: #FCD34D;
        }

        .job-progress {
            margin: 12px 0;
        }

        .progress-bar {
            height: 6px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 3px;
            transition: width var(--transition-normal);
        }

        .progress-fill.initializing {
            background: linear-gradient(90deg, #DDD6FE 0%, #A78BFA 50%, #DDD6FE 100%);
            background-size: 200% 100%;
            animation: shimmer 2s ease-in-out infinite;
        }
        [data-theme="dark"] .progress-fill.initializing {
            background: linear-gradient(90deg, #4C1D95 0%, #7C3AED 50%, #4C1D95 100%);
            background-size: 200% 100%;
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .job-details {
            display: flex;
            gap: 16px;
            font-size: 0.8125rem;
            color: var(--text-secondary);
            margin-top: 8px;
        }

        .job-detail {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .job-detail-value {
            font-weight: 500;
            font-variant-numeric: tabular-nums;
        }

        .job-saved {
            color: var(--success);
        }

        .job-error {
            color: var(--error);
            font-size: 0.8125rem;
            margin-top: 8px;
        }

        /* Error Helper Panel */
        .error-helper-toggle {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-family: var(--font-sans);
            cursor: pointer;
            padding: 4px 0;
            margin-top: 8px;
            transition: color var(--transition-fast);
        }

        .error-helper-toggle:hover {
            color: var(--text-primary);
        }

        .error-helper-toggle svg {
            width: 12px;
            height: 12px;
            transition: transform var(--transition-fast);
        }

        .error-helper-toggle.expanded svg {
            transform: rotate(180deg);
        }

        .error-helper-panel {
            display: none;
            margin-top: 12px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            font-size: 0.8125rem;
        }

        .error-helper-panel.expanded {
            display: block;
        }

        .error-helper-summary {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 12px;
        }

        .error-helper-summary-text {
            flex: 1;
            color: var(--text-primary);
            font-weight: 500;
        }

        .error-helper-confidence {
            display: inline-flex;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.02em;
            flex-shrink: 0;
        }

        .error-helper-confidence.high {
            background: var(--success-light);
            color: var(--success);
        }

        .error-helper-confidence.medium {
            background: var(--warning-light);
            color: var(--warning);
        }

        .error-helper-confidence.low {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .error-helper-section {
            margin-bottom: 12px;
        }

        .error-helper-section:last-child {
            margin-bottom: 0;
        }

        .error-helper-section-title {
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-tertiary);
            margin-bottom: 6px;
        }

        .error-helper-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .error-helper-list li {
            position: relative;
            padding-left: 16px;
            margin-bottom: 4px;
            color: var(--text-secondary);
        }

        .error-helper-list li:last-child {
            margin-bottom: 0;
        }

        .error-helper-list li::before {
            content: "";
            position: absolute;
            left: 0;
            top: 8px;
            width: 6px;
            height: 6px;
            background: var(--text-tertiary);
            border-radius: 50%;
        }

        .error-helper-matched {
            background: var(--warning-light);
            padding: 8px 10px;
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--warning);
            word-break: break-word;
            overflow-wrap: anywhere;
        }

        .error-helper-raw-toggle {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: none;
            border: none;
            color: var(--text-tertiary);
            font-size: 0.75rem;
            font-family: var(--font-sans);
            cursor: pointer;
            padding: 4px 0;
            transition: color var(--transition-fast);
        }

        .error-helper-raw-toggle:hover {
            color: var(--text-secondary);
        }

        .error-helper-raw-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .error-helper-copy {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-tertiary);
            font-size: 0.75rem;
            font-family: var(--font-sans);
            cursor: pointer;
            padding: 2px 8px;
            border-radius: 4px;
            transition: color var(--transition-fast), border-color var(--transition-fast);
        }

        .error-helper-copy:hover {
            color: var(--text-secondary);
            border-color: var(--text-secondary);
        }

        .error-helper-copy.copied {
            color: var(--success);
            border-color: var(--success);
        }

        .error-helper-raw-toggle svg {
            width: 10px;
            height: 10px;
            transition: transform var(--transition-fast);
        }

        .error-helper-raw-toggle.expanded svg {
            transform: rotate(180deg);
        }

        .error-helper-raw {
            display: none;
            margin-top: 8px;
            padding: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 0.6875rem;
            line-height: 1.6;
            color: var(--text-secondary);
            max-height: 200px;
            overflow: auto;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .error-helper-raw.expanded {
            display: block;
        }

        .error-helper-no-match {
            color: var(--text-tertiary);
            font-style: italic;
        }

        .job-actions {
            margin-top: 12px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .job-item.draggable {
            cursor: grab;
        }

        .job-item.dragging {
            opacity: 0.6;
            cursor: grabbing;
        }

        .job-item.drag-over {
            outline: 2px dashed var(--accent);
            outline-offset: 4px;
        }

        .queue-empty {
            padding: 24px 20px;
            text-align: center;
            color: var(--text-secondary);
        }

        .queue-empty-icon {
            font-size: 2rem;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        .queue-footer {
            padding: 12px 20px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border);
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .notify-label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8125rem;
            color: var(--text-secondary);
            cursor: pointer;
            user-select: none;
        }

        .notify-label input {
            accent-color: var(--accent);
            cursor: pointer;
        }

        /* Settings Menu */
        .settings-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-normal);
        }

        .settings-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .settings-panel {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 400px;
            max-width: 100%;
            background: var(--bg-secondary);
            z-index: 201;
            transform: translateX(100%);
            transition: transform var(--transition-normal);
            display: flex;
            flex-direction: column;
        }

        .settings-overlay.open .settings-panel {
            transform: translateX(0);
        }

        .settings-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .settings-title {
            font-weight: 600;
            font-size: 1.125rem;
        }

        .settings-close {
            width: 36px;
            height: 36px;
            border: none;
            background: transparent;
            border-radius: var(--radius-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transition: all var(--transition-fast);
        }

        .settings-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .setting-group {
            margin-bottom: 32px;
        }

        .setting-group:last-child {
            margin-bottom: 0;
        }

        .setting-group-title {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-tertiary);
            margin-bottom: 16px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--border);
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-info {
            flex: 1;
        }

        .setting-name {
            font-weight: 500;
            font-size: 0.9375rem;
            margin-bottom: 2px;
        }

        .setting-desc {
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        .setting-control {
            margin-left: 16px;
        }

        .setting-select {
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-family: var(--font-sans);
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            min-width: 160px;
        }

        .setting-input {
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 0.875rem;
            font-family: var(--font-sans);
            background: var(--bg-secondary);
            color: var(--text-primary);
            width: 200px;
        }

        .setting-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .setting-input::placeholder {
            color: var(--text-tertiary);
        }

        .settings-status {
            padding: 12px 24px;
            font-size: 0.8125rem;
            color: var(--success);
            min-height: 44px;
            display: flex;
            align-items: center;
        }

        .settings-status.error {
            color: var(--error);
        }

        .settings-footer {
            padding: 16px 24px;
            border-top: 1px solid var(--border);
            font-size: 12px;
            color: var(--text-tertiary);
            text-align: center;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .main {
                flex-direction: column;
                overflow-y: auto;
                align-items: stretch;
            }

            .browser-panel {
                flex: none;
            }

            .file-list {
                max-height: 50vh;
            }

            .queue-panel {
                width: 100%;
                position: static;
                align-self: stretch;
                max-height: none;
            }

            .queue-panel-inner {
                max-height: none;
            }

            .queue-list {
                max-height: 300px;
            }
        }

        @media (max-width: 768px) {
            .header {
                padding: 0 16px;
            }

            .stats-bar {
                gap: 12px;
                margin-left: 16px;
            }

            .stat-label {
                display: none;
            }

            .stat-value {
                font-size: 0.8125rem;
            }

            .main {
                padding: 16px;
                gap: 16px;
            }

            .settings-panel {
                width: 100%;
            }

            .actions-bar {
                flex-wrap: wrap;
            }

            .preset-select {
                width: 100%;
                min-width: 0;
            }
        }

        /* Loading State */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 12px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Hidden utility */
        .hidden {
            display: none !important;
        }

        /* ðŸ¦„ Unicorn Mode (purely cosmetic, easy to remove) */
        [data-unicorn="true"] .header {
            border-bottom: 2px solid transparent;
            border-image: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #ff6b6b) 1;
            animation: unicorn-shift 3s linear infinite;
        }
        @keyframes unicorn-shift {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        [data-unicorn="true"] .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        [data-unicorn="true"] .btn-primary:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-normal), visibility var(--transition-normal);
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            max-width: 420px;
            width: calc(100% - 32px);
            padding: 24px;
            transform: scale(0.95) translateY(10px);
            transition: transform var(--transition-normal);
        }

        .modal-overlay.active .modal {
            transform: scale(1) translateY(0);
        }

        .modal-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
        }

        .modal-message {
            font-size: 0.9375rem;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 24px;
        }

        .modal-options {
            margin: -8px 0 24px;
            display: none;
        }

        .modal-option {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .modal-option input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--accent);
            cursor: pointer;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-actions .btn {
            min-width: 100px;
        }

        /* Completed Jobs Section - compact collapsible view */
        .completed-section {
            border-top: 1px solid var(--border);
            padding: 12px;
            background: var(--bg-tertiary);
        }

        .completed-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            padding: 4px 0;
            user-select: none;
        }

        .completed-header:hover {
            color: var(--accent);
        }

        .completed-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8125rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .completed-count {
            background: var(--success-light);
            color: var(--success);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .completed-toggle {
            color: var(--text-tertiary);
            transition: transform var(--transition-fast);
        }

        .completed-toggle.expanded {
            transform: rotate(180deg);
        }

        .completed-list {
            max-height: 0;
            overflow: hidden;
            transition: max-height var(--transition-normal);
        }

        .completed-list.expanded {
            max-height: 300px;
            overflow-y: auto;
        }

        .completed-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.8125rem;
        }

        .completed-item:last-child {
            border-bottom: none;
        }

        .completed-item-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 12px;
        }

        .completed-item-saved {
            color: var(--success);
            font-weight: 500;
            font-size: 0.75rem;
            white-space: nowrap;
        }

        .completed-item-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .completed-item-time {
            color: var(--text-tertiary);
            font-size: 0.75rem;
        }

        /* Virtual Scrolling - Only visible items are rendered to DOM */
        .virtual-scroll-container {
            position: relative;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .virtual-scroll-content {
            position: relative;
        }

        .virtual-scroll-spacer-top,
        .virtual-scroll-spacer-bottom {
            width: 100%;
        }

        /* When virtual scroll is enabled, job items have fixed height for predictable layout */
        .queue-list.virtual-scroll-enabled .job-item {
            min-height: 72px;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="header">
            <div class="header-left">
                <div class="logo">
                    <div class="logo-icon">
                        <img src="/logo.png" alt="Shrinkray" width="32" height="32">
                    </div>
                    Shrinkray
                </div>
                <div class="stats-bar" id="stats-bar">
                    <div class="stat-item running">
                        <span class="stat-value" id="stat-running">0</span>
                        <span class="stat-label">running</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="stat-pending">0</span>
                        <span class="stat-label">pending</span>
                    </div>
                    <div class="stat-item success">
                        <span class="stat-value" id="stat-saved">0 MB</span>
                        <span class="stat-label">saved</span>
                    </div>
                </div>
            </div>
            <div class="header-right">
                <button class="menu-btn" id="theme-toggle" onclick="toggleTheme()" title="Toggle dark mode">
                    <!-- Sun icon (shown in dark mode) -->
                    <svg class="theme-icon-light" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                    <!-- Moon icon (shown in light mode) -->
                    <svg class="theme-icon-dark" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
                <button class="menu-btn" onclick="openSettings()" title="Settings">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"/>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/>
                    </svg>
                </button>
            </div>
        </header>

        <main class="main">
            <div class="browser-panel">
                <div class="panel">
                    <div class="file-list-bar">
                        <div class="breadcrumb" id="breadcrumb">
                            <div class="loading">
                                <div class="spinner"></div>
                                Loading...
                            </div>
                        </div>
                        <div class="file-list-controls">
                            <label for="file-sort">
                                Order by
                                <select id="file-sort" onchange="updateFileSort(this.value)">
                                    <option value="name">Name (Aâ€“Z)</option>
                                    <option value="size">Size (largest first)</option>
                                    <option value="type">Type (folders first)</option>
                                    <option value="modified">Modified (newest first)</option>
                                </select>
                            </label>
                            <label for="file-filter">
                                Filter
                                <select id="file-filter" onchange="updateFileFilter(this.value)">
                                    <option value="all">All items</option>
                                    <option value="workable">Folders + workable videos</option>
                                </select>
                            </label>
                            <label class="toggle" id="hide-empty-folders-container" style="display: none;">
                                <input type="checkbox" id="hide-empty-folders" onchange="updateHideEmptyFolders(this.checked)">
                                Hide empty folders
                            </label>
                        </div>
                    </div>
                    <div class="file-list-header hidden" id="file-list-header">
                        <label>
                            <input type="checkbox" class="file-checkbox" id="select-all-checkbox" onchange="toggleSelectAll(this)">
                            Select all
                        </label>
                        <span id="selection-count"></span>
                    </div>
                    <ul class="file-list" id="file-list">
                        <li class="loading">
                            <div class="spinner"></div>
                            Loading files...
                        </li>
                    </ul>
                    <div class="actions-bar">
                        <select class="preset-select" id="preset-select" onchange="onPresetChange()">
                            <option value="compress-hevc">Compress (HEVC)</option>
                        </select>
                        <label class="subfolder-toggle" title="When enabled, selecting a folder will include all video files from its subfolders">
                            <input type="checkbox" id="include-subfolders" checked>
                            <span>Include subfolders</span>
                        </label>
                        <button class="btn btn-secondary" onclick="markSelectedProcessed()" id="mark-processed-btn" disabled>Mark Processed</button>
                        <button class="btn btn-primary" onclick="startJobs()" id="start-btn" disabled>Start Transcode</button>
                        <span class="selection-count" id="selection-summary"></span>
                    </div>
                </div>
            </div>

            <div class="queue-panel">
                <div class="panel active-jobs-panel" id="active-panel" style="display: none;">
                    <div class="panel-header">
                        <button class="panel-toggle" type="button" onclick="togglePanel('active-panel')" aria-expanded="true" aria-controls="active-panel-content">
                            <span class="panel-title">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polygon points="5 3 19 12 5 21 5 3"/>
                                </svg>
                                Active
                            </span>
                            <svg class="panel-collapse-toggle" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </button>
                    </div>
                    <div class="panel-body active-panel-content" id="active-panel-content">
                        <div class="active-panel-section" id="now-processing-section">
                            <div class="active-panel-title">Now Processing</div>
                            <div id="now-processing-content"></div>
                        </div>
                        <div class="active-panel-section" id="up-next-section" style="display: none;">
                            <div class="active-panel-title">Up Next</div>
                            <div id="up-next-list"></div>
                        </div>
                    </div>
                </div>
                <div class="panel queue-panel-inner" id="queue-panel">
                    <div class="panel-header">
                        <button class="panel-toggle" type="button" onclick="togglePanel('queue-panel')" aria-expanded="true" aria-controls="queue-panel-content">
                            <span class="panel-title">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="8" y1="6" x2="21" y2="6"/>
                                    <line x1="8" y1="12" x2="21" y2="12"/>
                                    <line x1="8" y1="18" x2="21" y2="18"/>
                                    <line x1="3" y1="6" x2="3.01" y2="6"/>
                                    <line x1="3" y1="12" x2="3.01" y2="12"/>
                                    <line x1="3" y1="18" x2="3.01" y2="18"/>
                                </svg>
                                Queue
                            </span>
                            <span class="panel-toggle-actions">
                                <label class="notify-label" id="notify-container" style="display: none" onclick="event.stopPropagation()">
                                    <input type="checkbox" id="notify-checkbox" onchange="updateNotifySetting(this.checked)" onclick="event.stopPropagation()">
                                    <span>Notify when done</span>
                                </label>
                                <svg class="panel-collapse-toggle" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="6 9 12 15 18 9"></polyline>
                                </svg>
                            </span>
                        </button>
                    </div>
                    <div class="panel-body queue-panel-content" id="queue-panel-content">
                        <div class="queue-list" id="queue-list">
                            <div class="queue-empty">
                                <div class="queue-empty-icon">
                                    <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.3">
                                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                                        <path d="M3 9h18"/>
                                        <path d="M9 21V9"/>
                                    </svg>
                                </div>
                                <div>No jobs in queue</div>
                                <div style="font-size: 0.8125rem; margin-top: 4px; color: var(--text-tertiary)">Select files and start transcoding</div>
                            </div>
                        </div>
                        <!-- Completed Jobs Section -->
                        <div class="completed-section" id="completed-section" style="display: none;">
                            <div class="completed-header" onclick="toggleCompletedSection()">
                                <div class="completed-title">
                                    <span>Recently Completed</span>
                                    <span class="completed-count" id="completed-count">0</span>
                                </div>
                                <svg class="completed-toggle" id="completed-toggle" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="6 9 12 15 18 9"></polyline>
                                </svg>
                            </div>
                            <div class="completed-list" id="completed-list"></div>
                        </div>
                        <div class="queue-footer">
                            <button class="btn btn-secondary btn-sm" onclick="clearQueue()" style="flex: 1">Clear Queue</button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Settings Panel -->
    <div class="settings-overlay" id="settings-overlay" onclick="closeSettings(event)">
        <div class="settings-panel" onclick="event.stopPropagation()">
            <div class="settings-header">
                <span class="settings-title">Settings</span>
                <button class="settings-close" onclick="closeSettings()">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"/>
                        <line x1="6" y1="6" x2="18" y2="18"/>
                    </svg>
                </button>
            </div>
            <div class="settings-content">
                <div class="setting-group">
                    <div class="setting-group-title">Transcoding</div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Original files</div>
                            <div class="setting-desc">What happens after transcoding</div>
                        </div>
                        <div class="setting-control">
                            <select class="setting-select" id="setting-original-handling" onchange="updateSetting('original_handling', this.value)">
                                <option value="replace">Delete original</option>
                                <option value="keep">Keep as .old</option>
                            </select>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Concurrent jobs</div>
                            <div class="setting-desc">Simultaneous transcode tasks</div>
                        </div>
                        <div class="setting-control">
                            <select class="setting-select" id="setting-workers" onchange="updateSetting('workers', parseInt(this.value))">
                                <option value="1">1 (recommended)</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                                <option value="5">5</option>
                                <option value="6">6</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="setting-group">
                    <div class="setting-group-title">Browser</div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Hide processing files</div>
                            <div class="setting-desc">Hide .trickplay.tmp files from the browser</div>
                        </div>
                        <div class="setting-control">
                            <input type="checkbox" id="setting-hide-processing-tmp" onchange="toggleHideProcessingTmp(this.checked)" style="width: 18px; height: 18px; accent-color: var(--accent); cursor: pointer;">
                        </div>
                    </div>
                </div>
                <div class="setting-group">
                    <div class="setting-group-title">History</div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Processed videos</div>
                            <div class="setting-desc">Clear the stored processed history used for badges</div>
                        </div>
                        <div class="setting-control">
                            <button class="btn btn-secondary btn-sm" onclick="clearProcessedHistory()">Clear</button>
                        </div>
                    </div>
                </div>
                <div class="setting-group">
                    <div class="setting-group-title">Notifications</div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Pushover User Key</div>
                            <div class="setting-desc">Your Pushover user/group key</div>
                        </div>
                        <div class="setting-control">
                            <input type="text" class="setting-input" id="setting-pushover-user"
                                   placeholder="Enter user key" onchange="updateSetting('pushover_user_key', this.value)">
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Pushover App Token</div>
                            <div class="setting-desc">Your Pushover application token</div>
                        </div>
                        <div class="setting-control">
                            <input type="text" class="setting-input" id="setting-pushover-token"
                                   placeholder="Enter app token" onchange="updateSetting('pushover_app_token', this.value)">
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Test Notification</div>
                            <div class="setting-desc">Send a test to verify setup</div>
                        </div>
                        <div class="setting-control">
                            <button class="btn btn-secondary btn-sm" id="test-pushover-btn" onclick="testPushover()">Test</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">ntfy Server</div>
                            <div class="setting-desc">Server URL (default: https://ntfy.sh)</div>
                        </div>
                        <div class="setting-control">
                            <input type="text" class="setting-input" id="setting-ntfy-server"
                                   placeholder="https://ntfy.sh" onchange="updateSetting('ntfy_server', this.value)">
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">ntfy Topic</div>
                            <div class="setting-desc">Topic name for notifications</div>
                        </div>
                        <div class="setting-control">
                            <input type="text" class="setting-input" id="setting-ntfy-topic"
                                   placeholder="Enter topic" onchange="updateSetting('ntfy_topic', this.value)">
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">ntfy Token</div>
                            <div class="setting-desc">Optional access token</div>
                        </div>
                        <div class="setting-control">
                            <input type="text" class="setting-input" id="setting-ntfy-token"
                                   placeholder="Enter token (optional)" onchange="updateSetting('ntfy_token', this.value)">
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">Test ntfy</div>
                            <div class="setting-desc">Send a test to verify setup</div>
                        </div>
                        <div class="setting-control">
                            <button class="btn btn-secondary btn-sm" id="test-ntfy-btn" onclick="testNtfy()">Test</button>
                        </div>
                    </div>
                </div>
                <div class="setting-group">
                    <div class="setting-group-title">Fun</div>
                    <div class="setting-item">
                        <div class="setting-info">
                            <div class="setting-name">ðŸ¦„ Unicorn Mode</div>
                            <div class="setting-desc">Purely cosmetic sparkles (easy to remove)</div>
                        </div>
                        <div class="setting-control">
                            <input type="checkbox" id="setting-unicorn-mode" onchange="toggleUnicornMode(this.checked)" style="width: 18px; height: 18px; accent-color: var(--accent); cursor: pointer;">
                        </div>
                    </div>
                </div>
            </div>
            <div class="settings-status" id="settings-status"></div>
            <div class="settings-footer">Shrinkray v<span id="app-version"></span></div>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirm-modal" class="modal-overlay" onclick="closeConfirmModal(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-title" id="confirm-modal-title">Confirm</div>
            <div class="modal-message" id="confirm-modal-message"></div>
            <div class="modal-options" id="confirm-modal-options">
                <label class="modal-option" for="confirm-modal-remove-completed">
                    <input type="checkbox" id="confirm-modal-remove-completed" checked>
                    <span>Also remove recently completed jobs</span>
                </label>
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="confirm-modal-cancel">Cancel</button>
                <button class="btn btn-primary" id="confirm-modal-action">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        // Theme handling
        function getSystemTheme() {
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        function applyTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('shrinkray-theme', theme);
        }

        function toggleTheme() {
            const current = document.documentElement.getAttribute('data-theme') || 'light';
            const next = current === 'dark' ? 'light' : 'dark';
            applyTheme(next);
        }

        // Apply theme immediately to prevent flash
        (function() {
            const saved = localStorage.getItem('shrinkray-theme');
            const theme = saved || getSystemTheme();
            document.documentElement.setAttribute('data-theme', theme);
        })();

        // ðŸ¦„ Unicorn Mode (purely cosmetic, easy to remove)
        function toggleUnicornMode(enabled) {
            document.documentElement.setAttribute('data-unicorn', enabled);
            localStorage.setItem('shrinkray-unicorn', enabled);
            updateStartButtonText();
            if (enabled) {
                console.log('ðŸ¦„âœ¨ Unicorn Mode activated! Your transcodes are now 100% more magical âœ¨ðŸ¦„');
            }
        }

        function updateStartButtonText() {
            const btn = document.getElementById('start-btn');
            if (!btn) return;
            const unicornEnabled = document.documentElement.getAttribute('data-unicorn') === 'true';
            btn.textContent = unicornEnabled ? 'âœ¨ Start Magic âœ¨' : 'Start Transcode';
        }

        // Apply unicorn mode on load
        (function() {
            const unicorn = localStorage.getItem('shrinkray-unicorn') === 'true';
            if (unicorn) {
                document.documentElement.setAttribute('data-unicorn', 'true');
            }
        })();

        let currentPath = '';
        let selectedPaths = new Set();
        let fileListEntries = [];
        const storageKeys = {
            fileSort: 'shrinkray-file-sort',
            fileFilter: 'shrinkray-file-filter',
            hideEmptyFolders: 'shrinkray-hide-empty-folders',
            selectedPreset: 'shrinkray-selected-preset',
            includeSubfolders: 'shrinkray-include-subfolders',
            notifyOnComplete: 'shrinkray-notify-on-complete',
            clearRecentlyCompleted: 'shrinkray-clear-recently-completed'
        };

        const fileListState = {
            sort: 'name',
            filter: 'all',
            hideEmptyFolders: false
        };
        let preferredPresetId = localStorage.getItem(storageKeys.selectedPreset) || '';
        let eventSource = null;
        let cachedJobs = [];

        // Performance: Debounce refresh calls to avoid DOM thrashing
        let refreshDebounceTimer = null;
        let pendingRefreshNeeded = false;
        const REFRESH_DEBOUNCE_MS = 100; // Max 10 refreshes per second

        // Performance: Track stats locally to avoid fetching on every update
        let cachedStats = { pending: 0, pending_probe: 0, running: 0, complete: 0, failed: 0, total_saved: 0 };

        // Feature flags (loaded from server config)
        let featureFlags = {
            virtual_scroll: false,
            deferred_probing: false,
            paginated_init: false,
            batched_sse: true,
            delta_progress: true
        };

        // Virtual scrolling state
        let virtualScrollEnabled = false;
        let jobMap = new Map();      // id -> Job object for O(1) lookup
        let jobOrder = [];           // Array of job IDs in display order

        // Status indexes for O(1) filtering (used by updateActivePanel)
        const statusIndex = {
            pending_probe: new Set(),
            pending: new Set(),
            running: new Set(),
            complete: new Set(),
            failed: new Set(),
            cancelled: new Set()
        };

        // Virtual scroll configuration
        const VIRTUAL_SCROLL_CONFIG = {
            itemHeight: 72,      // Fixed height per job item in pixels
            overscan: 5,         // Extra items to render above/below viewport
            containerSelector: '#queue-list'
        };

        // Virtual scroll state
        let visibleRange = { start: 0, end: 20 };
        let scrollContainer = null;

        // Error helper UI state (preserve expand/collapse across rerenders)
        const errorHelperExpanded = new Set();
        const errorRawExpanded = new Set();

        // ========================================
        // Virtual Scroll Implementation
        // ========================================

        function initVirtualScroll() {
            if (!virtualScrollEnabled) return;

            scrollContainer = document.querySelector(VIRTUAL_SCROLL_CONFIG.containerSelector);
            if (!scrollContainer) return;

            scrollContainer.classList.add('virtual-scroll-enabled', 'virtual-scroll-container');

            // Throttled scroll handler
            let scrollRafId = null;
            scrollContainer.addEventListener('scroll', () => {
                if (scrollRafId !== null) return;
                scrollRafId = requestAnimationFrame(() => {
                    scrollRafId = null;
                    updateVisibleRange();
                });
            }, { passive: true });
        }

        function updateVisibleRange() {
            if (!virtualScrollEnabled || !scrollContainer) return;

            const scrollTop = scrollContainer.scrollTop;
            const viewportHeight = scrollContainer.clientHeight;
            const { itemHeight, overscan } = VIRTUAL_SCROLL_CONFIG;

            const newStart = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);
            const newEnd = Math.min(
                jobOrder.length,
                Math.ceil((scrollTop + viewportHeight) / itemHeight) + overscan
            );

            if (newStart !== visibleRange.start || newEnd !== visibleRange.end) {
                visibleRange = { start: newStart, end: newEnd };
                renderVirtualJobs();
            }
        }

        function renderVirtualJobs() {
            if (!virtualScrollEnabled || !scrollContainer) return;

            const { start, end } = visibleRange;
            const { itemHeight } = VIRTUAL_SCROLL_CONFIG;

            const topHeight = start * itemHeight;
            const bottomHeight = Math.max(0, (jobOrder.length - end) * itemHeight);

            const visibleIds = jobOrder.slice(start, end);
            const visibleJobsHtml = visibleIds.map(id => {
                const job = jobMap.get(id);
                return job ? renderJobHtml(job) : '';
            }).join('');

            scrollContainer.innerHTML = `
                <div class="virtual-scroll-spacer-top" style="height: ${topHeight}px"></div>
                ${visibleJobsHtml}
                <div class="virtual-scroll-spacer-bottom" style="height: ${bottomHeight}px"></div>
            `;
        }

        function addJobToVirtualState(job) {
            jobMap.set(job.id, job);
            jobOrder.push(job.id);
            addToStatusIndex(job);
        }

        function updateJobInVirtualState(job) {
            const oldJob = jobMap.get(job.id);
            if (oldJob) {
                removeFromStatusIndex(oldJob);
            }
            jobMap.set(job.id, job);
            addToStatusIndex(job);
        }

        function removeJobFromVirtualState(jobId) {
            const job = jobMap.get(jobId);
            if (job) {
                removeFromStatusIndex(job);
                jobMap.delete(jobId);
                const idx = jobOrder.indexOf(jobId);
                if (idx >= 0) {
                    jobOrder.splice(idx, 1);
                }
            }
        }

        function addToStatusIndex(job) {
            if (statusIndex[job.status]) {
                statusIndex[job.status].add(job.id);
            }
        }

        function removeFromStatusIndex(job) {
            if (statusIndex[job.status]) {
                statusIndex[job.status].delete(job.id);
            }
        }

        function getJobsByStatus(status) {
            const ids = statusIndex[status];
            if (!ids) return [];
            return Array.from(ids).map(id => jobMap.get(id)).filter(Boolean);
        }

        function isJobVisible(jobId) {
            const idx = jobOrder.indexOf(jobId);
            return idx >= visibleRange.start && idx < visibleRange.end;
        }

        function updateJobInView(job) {
            if (!virtualScrollEnabled) return;

            const idx = jobOrder.indexOf(job.id);
            if (idx >= visibleRange.start && idx < visibleRange.end) {
                // Job is visible, update its DOM element
                const localIdx = idx - visibleRange.start;
                const items = scrollContainer.querySelectorAll('.job-item');
                if (items[localIdx]) {
                    items[localIdx].outerHTML = renderJobHtml(job);
                }
            }
        }

        function clearVirtualState() {
            jobMap.clear();
            jobOrder = [];
            Object.values(statusIndex).forEach(set => set.clear());
            visibleRange = { start: 0, end: 20 };
        }

        function pruneErrorHelperState(jobs) {
            const activeIds = new Set(jobs.map(job => job.id));
            for (const id of errorHelperExpanded) {
                if (!activeIds.has(id)) {
                    errorHelperExpanded.delete(id);
                }
            }
            for (const id of errorRawExpanded) {
                if (!activeIds.has(id)) {
                    errorRawExpanded.delete(id);
                }
            }
        }

        // Escape HTML to prevent XSS
        function escapeHtml(str) {
            if (str == null) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        // Escape for CSS selector (job IDs in querySelector)
        function escapeCssSelector(str) {
            return String(str).replace(/["\\]/g, '\\$&');
        }

        // Error Helper: Pattern taxonomy for common ffmpeg errors
        // Each pattern has: pattern (string or regex), summary, confidence, causes, steps
        const ERROR_PATTERNS = [
            {
                id: 'no_such_file',
                pattern: /No such file or directory/i,
                summary: 'FFmpeg could not find the input file.',
                confidence: 'high',
                causes: [
                    'The file was moved, renamed, or deleted before transcoding started.',
                    'The file path contains special characters that weren\'t properly handled.',
                ],
                steps: [
                    'Verify the file still exists at the expected location.',
                    'Check if the file was moved by another process.',
                    'Try adding the file again from the file browser.',
                ],
            },
            {
                id: 'moov_atom',
                pattern: /moov atom not found/i,
                summary: 'The MP4 file is missing its moov atom (metadata header).',
                confidence: 'high',
                causes: [
                    'The file is an incomplete download or interrupted recording.',
                    'The file was truncated or corrupted during transfer.',
                ],
                steps: [
                    'Re-download or re-copy the source file.',
                    'If this is from a camera/phone, try exporting again from the original device.',
                    'Use a recovery tool like untrunc or ffmpeg\'s -movflags faststart to attempt repair.',
                ],
            },
            {
                id: 'invalid_data',
                pattern: /Invalid data found when processing input/i,
                summary: 'FFmpeg found corrupted or unrecognized data in the input.',
                confidence: 'high',
                causes: [
                    'The file is corrupted or has an unsupported container format.',
                    'The file header doesn\'t match the actual content.',
                ],
                steps: [
                    'Try re-downloading or re-copying the file.',
                    'Check if the file plays correctly in VLC or another player.',
                    'Try remuxing the file with ffmpeg: ffmpeg -i input -c copy output.mkv',
                ],
            },
            {
                id: 'codec_params',
                pattern: /Could not find codec parameters/i,
                summary: 'FFmpeg couldn\'t determine how to decode this file.',
                confidence: 'high',
                causes: [
                    'The file uses an unknown or unsupported codec.',
                    'The file\'s stream information is missing or corrupted.',
                ],
                steps: [
                    'Check file info with: ffprobe -v error -show_streams filename',
                    'Try converting with a different preset.',
                    'Ensure ffmpeg has the required codec libraries installed.',
                ],
            },
            {
                id: 'unknown_decoder',
                pattern: /Unknown decoder|Decoder .* not found|Unsupported codec/i,
                summary: 'FFmpeg doesn\'t have the decoder for this file\'s codec.',
                confidence: 'high',
                causes: [
                    'The file uses a proprietary or uncommon codec.',
                    'FFmpeg was compiled without support for this codec.',
                ],
                steps: [
                    'Check what codec the file uses: ffprobe -v error -select_streams v:0 -show_entries stream=codec_name filename',
                    'Install a version of ffmpeg with broader codec support.',
                    'Convert the file using different software first.',
                ],
            },
            {
                id: 'decode_error',
                pattern: /Error while decoding stream|decode_slice_header error|Invalid NAL unit/i,
                summary: 'FFmpeg encountered errors while decoding the video stream.',
                confidence: 'medium',
                causes: [
                    'The video stream contains corrupted frames.',
                    'The file was partially damaged during download or transfer.',
                ],
                steps: [
                    'Try re-downloading or re-copying the source file.',
                    'Check if the file plays with visual glitches in a video player.',
                    'Try adding -err_detect ignore_err to ignore minor errors.',
                ],
            },
            {
                id: 'too_many_packets',
                pattern: /Too many packets buffered for output stream/i,
                summary: 'FFmpeg ran out of buffer space for output packets.',
                confidence: 'medium',
                causes: [
                    'The input has unusual timing or very long keyframe intervals.',
                    'There\'s a mismatch between audio and video stream timing.',
                ],
                steps: [
                    'Try adding -max_muxing_queue_size 1024 or higher.',
                    'Check if the source file has sync issues.',
                    'Try processing video and audio separately.',
                ],
            },
            {
                id: 'permission_denied',
                pattern: /Permission denied/i,
                summary: 'FFmpeg doesn\'t have permission to access a file or directory.',
                confidence: 'high',
                causes: [
                    'The input file or output directory has restrictive permissions.',
                    'The file is locked by another process.',
                ],
                steps: [
                    'Check file and folder permissions.',
                    'Ensure no other application has the file open.',
                    'Try running the application with appropriate permissions.',
                ],
            },
            {
                id: 'nvenc_session_limit',
                pattern: /OpenEncodeSessionEx failed.*0x7|maximum simultaneous.*sessions|too many concurrent|InitializeEncoder failed/i,
                summary: 'NVENC concurrent encoding session limit reached.',
                confidence: 'high',
                causes: [
                    'Consumer NVIDIA GPUs limit concurrent NVENC sessions to 2-3.',
                    'Multiple workers are trying to use hardware encoding simultaneously.',
                ],
                steps: [
                    'Reduce the number of concurrent workers to 1 when using hardware encoding.',
                    'Wait for one job to finish before starting another.',
                    'Use software encoding if you need multiple concurrent jobs.',
                ],
            },
            {
                id: 'hwaccel_init',
                pattern: /Failed to initialise NVENC|Cannot load nvcuda|CUDA|VAAPI|videotoolbox.*failed|hwaccel.*failed/i,
                summary: 'Hardware acceleration initialization failed.',
                confidence: 'high',
                causes: [
                    'GPU drivers are outdated or not properly installed.',
                    'The GPU doesn\'t support the required encoding features.',
                    'Another process is using the hardware encoder.',
                ],
                steps: [
                    'Update your GPU drivers.',
                    'Try using a software encoder preset instead.',
                    'Check if other GPU-accelerated applications are running.',
                ],
            },
            {
                id: 'out_of_memory',
                pattern: /Cannot allocate memory|Out of memory|memory allocation failed/i,
                summary: 'The system ran out of memory during transcoding.',
                confidence: 'high',
                causes: [
                    'The video resolution or bitrate is too high for available RAM.',
                    'Too many concurrent transcoding jobs.',
                ],
                steps: [
                    'Close other memory-intensive applications.',
                    'Reduce the number of concurrent workers.',
                    'Try a lower resolution or bitrate preset.',
                ],
            },
            {
                id: 'disk_full',
                pattern: /No space left on device|disk full/i,
                summary: 'The disk ran out of space.',
                confidence: 'high',
                causes: [
                    'The output drive doesn\'t have enough free space.',
                    'The temp directory is on a full partition.',
                ],
                steps: [
                    'Free up disk space on the output drive.',
                    'Check available space in the temp directory.',
                    'Consider outputting to a different drive.',
                ],
            },
            {
                id: 'dts_error',
                pattern: /non-monotonous DTS|DTS.*out of order/i,
                summary: 'The video has timing/timestamp issues.',
                confidence: 'medium',
                causes: [
                    'The source video has corrupted or incorrect timestamps.',
                    'The file was improperly edited or concatenated.',
                ],
                steps: [
                    'This is often just a warning. If the output looks fine, ignore it.',
                    'Try remuxing first: ffmpeg -i input -c copy -fflags +genpts output.mkv',
                    'Re-encode from the original source if available.',
                ],
            },
            {
                id: 'output_larger',
                pattern: /larger than original|is larger than/i,
                summary: 'The transcoded file would be larger than the original.',
                confidence: 'high',
                causes: [
                    'The source is already well-compressed or uses an efficient codec.',
                    'The file is very short, so codec overhead exceeds any compression gains.',
                    'The source bitrate is already lower than the target preset.',
                ],
                steps: [
                    'This is expected behavior - Shrinkray skips files that would grow larger.',
                    'No action needed. The original file is already optimal for its size.',
                    'If you still want to convert, consider using a lower quality preset.',
                ],
            },
            {
                id: 'already_target_codec',
                pattern: /already encoded in (AV1|HEVC)/i,
                summary: 'The file is already encoded in the target codec.',
                confidence: 'high',
                causes: [
                    'The source file is already using the same codec as the selected preset.',
                    'Re-encoding would not provide any compression benefits.',
                ],
                steps: [
                    'No action needed - your file is already optimally encoded.',
                    'If you want to reduce the file size further, try a lower quality preset.',
                    'Consider using a different codec preset if you need to re-encode.',
                ],
            },
            {
                id: 'subtitle_copy',
                pattern: /Subtitle codec .* is not supported|Cannot convert subtitle|subtitle stream.*not supported|Subtitle encoding failed/i,
                summary: 'A subtitle stream could not be copied to the output container.',
                confidence: 'medium',
                causes: [
                    'The source has bitmap subtitles (DVD/Blu-ray) that MKV cannot remux directly.',
                    'The subtitle format is incompatible with the output container.',
                ],
                steps: [
                    'Re-run with a preset that skips subtitles, or edit the command manually.',
                    'Consider extracting subtitles separately if you need them.',
                    'Some subtitle formats require transcoding rather than copying.',
                ],
            },
        ];

        // Analyze error and return structured diagnosis
        function analyzeError(job) {
            const stderr = job.stderr || '';
            const error = job.error || '';
            const combined = stderr + '\n' + error;

            // Try to match patterns
            for (const pattern of ERROR_PATTERNS) {
                const regex = pattern.pattern instanceof RegExp
                    ? pattern.pattern
                    : new RegExp(pattern.pattern, 'i');

                const match = combined.match(regex);
                if (match) {
                    return {
                        summary: pattern.summary,
                        confidence: pattern.confidence,
                        matched: match[0],
                        causes: pattern.causes,
                        steps: pattern.steps,
                        hasStderr: !!stderr,
                        stderr: stderr,
                    };
                }
            }

            // No pattern matched - return fallback
            return {
                summary: 'Could not confidently identify this error.',
                confidence: 'low',
                matched: null,
                causes: ['The error doesn\'t match any known patterns.'],
                steps: ['Review the raw ffmpeg output below for more details.'],
                hasStderr: !!stderr,
                stderr: stderr,
            };
        }

        // Render error helper HTML (all strings are escaped)
        function renderErrorHelper(job) {
            // Only render for failed jobs with stderr
            if (job.status !== 'failed') return '';

            const analysis = analyzeError(job);
            const isExpanded = errorHelperExpanded.has(job.id);
            const isRawExpanded = errorRawExpanded.has(job.id);
            const safeId = escapeHtml(job.id);
            const safeSummary = escapeHtml(analysis.summary);
            const safeMatched = analysis.matched ? escapeHtml(analysis.matched) : null;
            const safeStderr = escapeHtml(analysis.stderr);

            const causesHtml = analysis.causes
                .map(c => `<li>${escapeHtml(c)}</li>`)
                .join('');

            const stepsHtml = analysis.steps
                .map(s => `<li>${escapeHtml(s)}</li>`)
                .join('');

            const confidenceClass = analysis.confidence;

            return `
                <button class="error-helper-toggle ${isExpanded ? 'expanded' : ''}" onclick="toggleErrorHelper('${safeId}')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                    Explain error
                </button>
                <div class="error-helper-panel ${isExpanded ? 'expanded' : ''}" id="error-helper-${safeId}">
                    <div class="error-helper-summary">
                        <span class="error-helper-summary-text">${safeSummary}</span>
                        <span class="error-helper-confidence ${confidenceClass}">${analysis.confidence}</span>
                    </div>

                    ${safeMatched ? `
                        <div class="error-helper-section">
                            <div class="error-helper-section-title">Matched Pattern</div>
                            <div class="error-helper-matched">${safeMatched}</div>
                        </div>
                    ` : `
                        <div class="error-helper-section">
                            <div class="error-helper-no-match">No specific pattern matched.</div>
                        </div>
                    `}

                    <div class="error-helper-section">
                        <div class="error-helper-section-title">Likely Causes</div>
                        <ul class="error-helper-list">${causesHtml}</ul>
                    </div>

                    <div class="error-helper-section">
                        <div class="error-helper-section-title">What To Try</div>
                        <ul class="error-helper-list">${stepsHtml}</ul>
                    </div>

                    <div class="error-helper-section">
                        <div class="error-helper-raw-actions">
                            <button class="error-helper-raw-toggle ${isRawExpanded ? 'expanded' : ''}" onclick="toggleRawOutput('${safeId}')">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="6 9 12 15 18 9"></polyline>
                                </svg>
                                Show raw ffmpeg output
                            </button>
                            <button class="error-helper-copy" type="button" onclick="copyRawOutput('${safeId}')">Copy raw output</button>
                        </div>
                        <div class="error-helper-raw ${isRawExpanded ? 'expanded' : ''}" id="error-raw-${safeId}">${safeStderr || 'No stderr output captured.'}</div>
                    </div>
                </div>
            `;
        }

        // Toggle error helper panel
        function toggleErrorHelper(jobId) {
            const safeSelector = `#error-helper-${escapeCssSelector(jobId)}`;
            const panel = document.querySelector(safeSelector);
            const toggleSelector = `.job-item[data-job-id="${escapeCssSelector(jobId)}"] .error-helper-toggle`;
            const toggle = document.querySelector(toggleSelector);

            if (panel && toggle) {
                const isExpanded = panel.classList.toggle('expanded');
                toggle.classList.toggle('expanded', isExpanded);
                if (isExpanded) {
                    errorHelperExpanded.add(jobId);
                } else {
                    errorHelperExpanded.delete(jobId);
                }
            }
        }

        // Toggle raw output panel
        function toggleRawOutput(jobId) {
            const safeSelector = `#error-raw-${escapeCssSelector(jobId)}`;
            const raw = document.querySelector(safeSelector);
            const toggleSelector = `#error-helper-${escapeCssSelector(jobId)} .error-helper-raw-toggle`;
            const toggle = document.querySelector(toggleSelector);

            if (raw && toggle) {
                const isExpanded = raw.classList.toggle('expanded');
                toggle.classList.toggle('expanded', isExpanded);
                if (isExpanded) {
                    errorRawExpanded.add(jobId);
                } else {
                    errorRawExpanded.delete(jobId);
                }
            }
        }

        async function copyRawOutput(jobId) {
            const job = cachedJobs.find(j => j.id === jobId);
            const rawOutput = job && job.stderr ? job.stderr : '';

            if (!rawOutput) {
                alert('No stderr output captured for this job.');
                return;
            }

            let copied = false;

            if (navigator.clipboard && navigator.clipboard.writeText) {
                try {
                    await navigator.clipboard.writeText(rawOutput);
                    copied = true;
                } catch (err) {
                    copied = false;
                }
            }

            if (!copied) {
                const textarea = document.createElement('textarea');
                textarea.value = rawOutput;
                textarea.setAttribute('readonly', '');
                textarea.style.position = 'absolute';
                textarea.style.left = '-9999px';
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    copied = document.execCommand('copy');
                } catch (err) {
                    copied = false;
                }
                document.body.removeChild(textarea);
            }

            const copySelector = `#error-helper-${escapeCssSelector(jobId)} .error-helper-copy`;
            const copyButton = document.querySelector(copySelector);
            if (copyButton) {
                const originalLabel = copyButton.dataset.label || copyButton.textContent;
                copyButton.dataset.label = originalLabel;
                copyButton.textContent = copied ? 'Copied!' : 'Copy failed';
                copyButton.classList.toggle('copied', copied);
                setTimeout(() => {
                    copyButton.textContent = originalLabel;
                    copyButton.classList.remove('copied');
                }, 1500);
            }
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            if (bytes < 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatDuration(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            if (h > 0) return `${h}h ${m}m`;
            if (m > 0) return `${m}m ${s}s`;
            return `${s}s`;
        }

        function getStartedAtMs(job) {
            if (!job || !job.started_at) return null;
            const started = new Date(job.started_at);
            const startedMs = started.getTime();
            if (Number.isNaN(startedMs)) return null;
            return startedMs;
        }

        function ensureLocalStartedAt(job, startedMs) {
            if (!job || job.status !== 'running') return;
            if (job.local_started_at) return;
            const now = Date.now();
            if (startedMs === null || startedMs > now + 1000) {
                job.local_started_at = now;
            }
        }

        function getElapsedSeconds(job) {
            if (!job) return null;
            if (job.status === 'complete' && job.transcode_secs) {
                return job.transcode_secs;
            }
            const startedMs = getStartedAtMs(job);
            ensureLocalStartedAt(job, startedMs);
            if (startedMs === null) {
                if (job.local_started_at) {
                    return Math.max(0, Math.floor((Date.now() - job.local_started_at) / 1000));
                }
                return null;
            }
            let endTime = Date.now();
            if (job.completed_at) {
                const completed = new Date(job.completed_at);
                if (!Number.isNaN(completed.getTime())) {
                    endTime = completed.getTime();
                }
            }
            if (job.local_started_at && startedMs > endTime) {
                return Math.max(0, Math.floor((endTime - job.local_started_at) / 1000));
            }
            const elapsedSeconds = Math.max(0, Math.floor((endTime - startedMs) / 1000));
            return elapsedSeconds;
        }

        function formatElapsed(job) {
            const seconds = getElapsedSeconds(job);
            if (seconds === null) return null;
            return formatDuration(seconds);
        }

        function renderRunningDetails(progress, speed, etaValue, elapsed) {
            return `
                <span class="job-detail"><span class="job-detail-value" data-role="progress">${progress.toFixed(1)}%</span></span>
                <span class="job-detail"><span class="job-detail-value" data-role="speed">${speed.toFixed(2)}x</span></span>
                <span class="job-detail">ETA: <span class="job-detail-value" data-role="eta">${etaValue}</span></span>
                ${elapsed ? `<span class="job-detail">Elapsed: <span class="job-detail-value" data-role="elapsed">${elapsed}</span></span>` : ''}
            `;
        }

        function updateRunningDetails(detailsEl, progress, speed, etaValue, elapsed) {
            if (!detailsEl) return;
            const progressEl = detailsEl.querySelector('[data-role="progress"]');
            const speedEl = detailsEl.querySelector('[data-role="speed"]');
            const etaEl = detailsEl.querySelector('[data-role="eta"]');
            const elapsedEl = detailsEl.querySelector('[data-role="elapsed"]');

            if (!progressEl || !speedEl || !etaEl) {
                detailsEl.innerHTML = renderRunningDetails(progress, speed, etaValue, elapsed);
                return;
            }

            progressEl.textContent = `${progress.toFixed(1)}%`;
            speedEl.textContent = `${speed.toFixed(2)}x`;
            etaEl.textContent = etaValue;

            if (elapsed) {
                if (elapsedEl) {
                    elapsedEl.textContent = elapsed;
                } else {
                    detailsEl.insertAdjacentHTML(
                        'beforeend',
                        `<span class="job-detail">Elapsed: <span class="job-detail-value" data-role="elapsed">${elapsed}</span></span>`
                    );
                }
            } else if (elapsedEl) {
                const elapsedDetail = elapsedEl.closest('.job-detail');
                if (elapsedDetail) {
                    elapsedDetail.remove();
                }
            }
        }

        function updateFileSort(value) {
            fileListState.sort = value;
            localStorage.setItem(storageKeys.fileSort, value);
            renderFileList();
        }

        function updateFileFilter(value) {
            fileListState.filter = value;
            localStorage.setItem(storageKeys.fileFilter, value);
            updateEmptyFolderToggleVisibility();
            renderFileList();
        }

        function updateHideEmptyFolders(checked) {
            fileListState.hideEmptyFolders = checked;
            localStorage.setItem(storageKeys.hideEmptyFolders, String(checked));
            renderFileList();
        }

        function updateEmptyFolderToggleVisibility() {
            const container = document.getElementById('hide-empty-folders-container');
            const checkbox = document.getElementById('hide-empty-folders');
            if (fileListState.filter === 'workable') {
                container.style.display = 'flex';
                checkbox.checked = fileListState.hideEmptyFolders;
            } else {
                container.style.display = 'none';
                checkbox.checked = false;
                fileListState.hideEmptyFolders = false;
            }
        }

        function getEntrySize(entry) {
            if (entry.is_dir) {
                return entry.total_size || 0;
            }
            return entry.size || 0;
        }

        function sortFileEntries(entries) {
            const sorted = [...entries];
            sorted.sort((a, b) => {
                if (fileListState.sort === 'name') {
                    return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
                }
                if (fileListState.sort === 'size') {
                    const sizeDiff = getEntrySize(b) - getEntrySize(a);
                    if (sizeDiff !== 0) return sizeDiff;
                    return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
                }
                if (fileListState.sort === 'type') {
                    if (a.is_dir !== b.is_dir) {
                        return a.is_dir ? -1 : 1;
                    }
                    return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
                }
                if (fileListState.sort === 'modified') {
                    const timeA = new Date(a.mod_time).getTime() || 0;
                    const timeB = new Date(b.mod_time).getTime() || 0;
                    if (timeB !== timeA) return timeB - timeA;
                    return a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
                }
                return 0;
            });
            return sorted;
        }

        function filterFileEntries(entries) {
            if (fileListState.filter === 'workable') {
                return entries.filter(entry => {
                    if (entry.is_dir) {
                        if (fileListState.hideEmptyFolders) {
                            return (entry.file_count || 0) > 0;
                        }
                        return true;
                    }
                    return entry.video_info;
                });
            }
            return entries;
        }

        function renderFileList() {
            const list = document.getElementById('file-list');
            const header = document.getElementById('file-list-header');
            const selectAllCheckbox = document.getElementById('select-all-checkbox');

            if (!fileListEntries || fileListEntries.length === 0) {
                list.innerHTML = '<li class="file-list-empty">This folder is empty</li>';
                header.classList.add('hidden');
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
                return;
            }

            const filteredEntries = filterFileEntries(fileListEntries);
            if (filteredEntries.length === 0) {
                list.innerHTML = '<li class="file-list-empty">No items match the current filter</li>';
                header.classList.add('hidden');
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
                return;
            }

            const sortedEntries = sortFileEntries(filteredEntries);

            const hasSelectableItems = sortedEntries.some(entry =>
                (!entry.is_dir && entry.video_info) || (entry.is_dir && (entry.file_count || 0) > 0)
            );

            if (hasSelectableItems) {
                header.classList.remove('hidden');
            } else {
                header.classList.add('hidden');
            }

            list.innerHTML = sortedEntries.map(entry => {
                const isVideo = !entry.is_dir && entry.video_info;
                const hasVideos = entry.is_dir && (entry.file_count || 0) > 0;
                const isSelectable = isVideo || hasVideos;
                const iconClass = entry.is_dir ? 'folder' : (isVideo ? 'video' : 'other');
                const icon = entry.is_dir
                    ? `<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/></svg>`
                    : isVideo
                        ? `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>`
                        : `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>`;

                let metaHtml = '';
                if (entry.is_dir) {
                    const count = entry.file_count || 0;
                    const processed = entry.processed_count || 0;
                    metaHtml = `<span>${processed}/${count} processed</span>`;
                } else if (isVideo) {
                    const vi = entry.video_info;
                    const codec = vi.video_codec?.toLowerCase() || '';
                    let codecClass = 'h264';
                    if (codec.includes('hevc') || codec.includes('h265')) {
                        codecClass = 'hevc';
                    } else if (codec.includes('av1')) {
                        codecClass = 'av1';
                    }
                    metaHtml = `<span class="codec-badge ${codecClass}">${vi.video_codec}</span><span>${vi.width}x${vi.height}</span>`;
                }

                const count = entry.file_count || 0;
                const processed = entry.processed_count || 0;
                const isFullyProcessed = entry.is_dir ? count > 0 && processed === count : entry.processed;
                const processedTag = isFullyProcessed ? '<span class="processed-tag">Processed</span>' : '';
                const canMarkProcessed = isSelectable && !isFullyProcessed;
                const markProcessedButton = canMarkProcessed
                    ? `<button class="btn btn-secondary btn-sm file-action-btn" data-path="${escapeHtml(entry.path)}" onclick="handleMarkProcessedClick(event, this)">Mark Processed</button>`
                    : '';
                const isSelected = selectedPaths.has(entry.path);
                const dblClickHandler = entry.is_dir ? ' ondblclick="handleFolderDoubleClick(this, event)"' : '';
                return `<li class="file-item${isSelected ? ' selected' : ''}" data-path="${entry.path}" data-is-dir="${entry.is_dir}" onclick="handleFileClick(this, event)"${dblClickHandler}>
                    ${isSelectable ? `<input type="checkbox" class="file-checkbox" onclick="handleCheckbox(this, event)" data-path="${entry.path}"${isSelected ? ' checked' : ''}>` : '<div style="width: 18px"></div>'}
                    <div class="file-icon ${iconClass}">${icon}</div>
                    <div class="file-info">
                        <div class="file-name">${entry.name}</div>
                        <div class="file-meta">${metaHtml}</div>
                    </div>
                    <div class="file-trailing">
                        ${processedTag}
                        ${markProcessedButton}
                        <div class="file-size">${formatBytes(getEntrySize(entry))}</div>
                    </div>
                </li>`;
            }).join('');

            updateButtons();
        }

        async function browse(path = '', preserveSelections = false, options = {}) {
            const { updateHistory = true, replaceHistory = false } = options;
            try {
                const url = path ? `/api/browse?path=${encodeURIComponent(path)}` : '/api/browse';
                const resp = await fetch(url);
                const data = await resp.json();

                currentPath = data.path;
                if (!preserveSelections) {
                    selectedPaths.clear();
                }
                updateButtons();

                if (updateHistory) {
                    const nextUrl = new URL(window.location.href);
                    if (currentPath) {
                        nextUrl.searchParams.set('path', currentPath);
                    } else {
                        nextUrl.searchParams.delete('path');
                    }
                    const state = { path: currentPath };
                    if (replaceHistory) {
                        history.replaceState(state, '', nextUrl);
                    } else {
                        history.pushState(state, '', nextUrl);
                    }
                }

                // Update breadcrumb
                const breadcrumb = document.getElementById('breadcrumb');
                const parts = data.path.split('/').filter(Boolean);
                let crumbs = `<a href="#" onclick="browse(''); return false;">Home</a>`;
                if (parts.length === 0) {
                    crumbs += `<span class="breadcrumb-sep">/</span>`;
                    crumbs += `<span class="breadcrumb-current">Root</span>`;
                } else {
                    let cumulativePath = '';
                    parts.forEach((part, index) => {
                        cumulativePath += `/${part}`;
                        const isLast = index === parts.length - 1;
                        crumbs += `<span class="breadcrumb-sep">/</span>`;
                        if (isLast) {
                            crumbs += `<span class="breadcrumb-current">${escapeHtml(part)}</span>`;
                        } else {
                            crumbs += `<a href="#" onclick="browse('${cumulativePath}'); return false;">${escapeHtml(part)}</a>`;
                        }
                    });
                }
                breadcrumb.innerHTML = crumbs;

                // Update file list
                fileListEntries = data.entries || [];
                updateEmptyFolderToggleVisibility();
                renderFileList();

            } catch (err) {
                console.error('Browse error:', err);
            }
        }

        function handleCheckbox(checkbox, event) {
            event.stopPropagation();
            const path = checkbox.dataset.path;
            const row = checkbox.closest('.file-item');

            if (checkbox.checked) {
                selectedPaths.add(path);
                row.classList.add('selected');
            } else {
                selectedPaths.delete(path);
                row.classList.remove('selected');
            }
            updateButtons();
        }

        function handleFileClick(el, event) {
            if (event.target.classList.contains('file-checkbox')) return;

            const path = el.dataset.path;
            const isDir = el.dataset.isDir === 'true';
            const checkbox = el.querySelector('.file-checkbox');

            if (isDir) {
                // If folder has a checkbox (has videos), single click selects it
                // Double click navigates into it
                if (checkbox) {
                    checkbox.checked = !checkbox.checked;
                    if (checkbox.checked) {
                        selectedPaths.add(path);
                        el.classList.add('selected');
                    } else {
                        selectedPaths.delete(path);
                        el.classList.remove('selected');
                    }
                    updateButtons();
                } else {
                    // Folder has no videos, navigate into it
                    browse(path);
                }
            } else {
                // File: toggle selection
                if (checkbox) {
                    checkbox.checked = !checkbox.checked;
                    if (checkbox.checked) {
                        selectedPaths.add(path);
                        el.classList.add('selected');
                    } else {
                        selectedPaths.delete(path);
                        el.classList.remove('selected');
                    }
                    updateButtons();
                }
            }
        }

        function handleFolderDoubleClick(el, event) {
            const path = el.dataset.path;
            browse(path);
        }

        function toggleSelectAll(checkbox) {
            const allCheckboxes = document.querySelectorAll('.file-item .file-checkbox');
            allCheckboxes.forEach(cb => {
                cb.checked = checkbox.checked;
                const row = cb.closest('.file-item');
                const path = cb.dataset.path;
                if (checkbox.checked) {
                    selectedPaths.add(path);
                    row.classList.add('selected');
                } else {
                    selectedPaths.delete(path);
                    row.classList.remove('selected');
                }
            });
            updateButtons();
        }

        function updateButtons() {
            const hasSelection = selectedPaths.size > 0;
            document.getElementById('start-btn').disabled = !hasSelection;
            document.getElementById('mark-processed-btn').disabled = !hasSelection;

            const summary = document.getElementById('selection-summary');
            if (hasSelection) {
                summary.textContent = `${selectedPaths.size} file${selectedPaths.size > 1 ? 's' : ''} selected`;
            } else {
                summary.textContent = '';
            }

            // Update select-all checkbox
            const selectAllCheckbox = document.getElementById('select-all-checkbox');
            const allCheckboxes = document.querySelectorAll('.file-item .file-checkbox');
            if (allCheckboxes.length > 0) {
                const allChecked = Array.from(allCheckboxes).every(cb => cb.checked);
                const someChecked = Array.from(allCheckboxes).some(cb => cb.checked);
                selectAllCheckbox.checked = allChecked;
                selectAllCheckbox.indeterminate = someChecked && !allChecked;
            }
        }

        function onPresetChange() {
            const preset = document.getElementById('preset-select').value;
            preferredPresetId = preset;
            localStorage.setItem(storageKeys.selectedPreset, preset);
        }

        function isEntryFullyProcessed(entry) {
            if (!entry) return false;
            if (entry.is_dir) {
                const count = entry.file_count || 0;
                const processed = entry.processed_count || 0;
                return count > 0 && processed === count;
            }
            return !!entry.processed;
        }

        function clearSelections() {
            selectedPaths.clear();
            document.querySelectorAll('.file-item.selected').forEach(el => {
                el.classList.remove('selected');
                const cb = el.querySelector('.file-checkbox');
                if (cb) cb.checked = false;
            });
            updateButtons();

            const selectAllCheckbox = document.getElementById('select-all-checkbox');
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            }
        }

        async function startJobs() {
            if (selectedPaths.size === 0) return;

            try {
                const preset = document.getElementById('preset-select').value;
                const includeSubfolders = document.getElementById('include-subfolders').checked;
                const entryMap = new Map((fileListEntries || []).map(entry => [entry.path, entry]));
                const selectedPathList = Array.from(selectedPaths);
                const selectedEntries = selectedPathList.map(path => entryMap.get(path)).filter(Boolean);
                const processedPaths = new Set(selectedEntries.filter(isEntryFullyProcessed).map(entry => entry.path));
                const partiallyProcessedDirs = selectedEntries.filter(entry => {
                    if (!entry || !entry.is_dir) return false;
                    const count = entry.file_count || 0;
                    const processed = entry.processed_count || 0;
                    return count > 0 && processed > 0 && processed < count;
                });
                const hasProcessed = processedPaths.size > 0 || partiallyProcessedDirs.length > 0;
                const hasUnprocessed = selectedPathList.some(path => !processedPaths.has(path)) || partiallyProcessedDirs.length > 0;
                let selectedJobPaths = selectedPathList;

                if (hasProcessed && hasUnprocessed) {
                    const includeProcessed = await confirmModalChoice(
                        'Include processed items?',
                        'Some selected items include files that are already processed. Do you want to include them in this transcode?',
                        { actionText: 'Include', cancelText: 'Exclude' }
                    );
                    if (!includeProcessed) {
                        selectedJobPaths = selectedPathList.filter(path => !processedPaths.has(path));
                    }
                }

                const resp = await fetch('/api/jobs', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        paths: selectedJobPaths,
                        preset_id: preset,
                        include_subfolders: includeSubfolders
                    })
                });
                const data = await resp.json();

                // Check for validation errors (bad request)
                if (data.error) {
                    alert(data.error);
                    return;
                }

                // Clear selections immediately - jobs will appear via SSE as they're processed
                clearSelections();

            } catch (err) {
                console.error('Start jobs error:', err);
            }
        }

        function handleMarkProcessedClick(event, button) {
            event.stopPropagation();
            const path = button.dataset.path;
            if (!path) return;
            const includeSubfolders = document.getElementById('include-subfolders').checked;
            markPathsProcessed([path], includeSubfolders);
        }

        async function markSelectedProcessed() {
            if (selectedPaths.size === 0) return;
            const includeSubfolders = document.getElementById('include-subfolders').checked;
            const entryMap = new Map((fileListEntries || []).map(entry => [entry.path, entry]));
            const selectedPathList = Array.from(selectedPaths);
            const selectedEntries = selectedPathList.map(path => entryMap.get(path)).filter(Boolean);
            const processedPaths = new Set(selectedEntries.filter(isEntryFullyProcessed).map(entry => entry.path));
            const unprocessedPaths = selectedPathList.filter(path => !processedPaths.has(path));

            if (unprocessedPaths.length === 0) {
                alert('Selected items are already marked as processed.');
                return;
            }

            await markPathsProcessed(unprocessedPaths, includeSubfolders);
            clearSelections();
        }

        async function markPathsProcessed(paths, includeSubfolders) {
            try {
                const resp = await fetch('/api/processed/mark', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        paths: paths,
                        include_subfolders: includeSubfolders
                    })
                });
                const data = await resp.json();
                if (!resp.ok) {
                    throw new Error(data.error || 'Failed to mark processed items');
                }
                await browse(currentPath, true, { updateHistory: false });
            } catch (err) {
                console.error('Mark processed error:', err);
                alert(err.message || 'Failed to mark processed items');
            }
        }

        async function cancelJob(id) {
            try {
                await fetch(`/api/jobs/${id}`, { method: 'DELETE' });
            } catch (err) {
                console.error('Cancel error:', err);
            }
        }

        async function moveJob(id, direction) {
            try {
                const resp = await fetch(`/api/jobs/${id}/reorder`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ direction })
                });
                if (!resp.ok) {
                    const data = await resp.json();
                    throw new Error(data.error || 'Failed to move job');
                }
                refreshJobs();
            } catch (err) {
                console.error('Reorder error:', err);
                alert(err.message || 'Failed to move job');
            }
        }

        async function moveJobTo(id, beforeId) {
            try {
                const resp = await fetch(`/api/jobs/${id}/move`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ before_id: beforeId || '' })
                });
                if (!resp.ok) {
                    const data = await resp.json();
                    throw new Error(data.error || 'Failed to move job');
                }
                refreshJobs();
            } catch (err) {
                console.error('Move error:', err);
                alert(err.message || 'Failed to move job');
            }
        }

        async function retryJob(id) {
            try {
                const resp = await fetch(`/api/jobs/${id}/retry`, { method: 'POST' });
                if (!resp.ok) {
                    const data = await resp.json();
                    alert(data.error || 'Failed to retry job');
                }
            } catch (err) {
                console.error('Retry error:', err);
            }
        }

        function clearQueue() {
            showConfirmModal(
                'Clear Queue',
                'This will remove all non-active jobs from the queue (including pending jobs). Your active jobs will not be affected.',
                async () => {
                    const removeCompleted = document.getElementById('confirm-modal-remove-completed').checked;
                    try {
                        await fetch('/api/jobs/clear', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ include_completed: removeCompleted })
                        });
                        refreshJobs();
                    } catch (err) {
                        console.error('Clear error:', err);
                    }
                },
                { showRemoveCompletedToggle: true, removeCompletedDefault: true }
            );
        }

        // Confirm Modal
        let confirmCallback = null;
        let confirmCancelCallback = null;

        function showConfirmModal(title, message, onConfirm, options = {}) {
            document.getElementById('confirm-modal-title').textContent = title;
            document.getElementById('confirm-modal-message').textContent = message;
            confirmCallback = onConfirm;
            confirmCancelCallback = options.onCancel || null;
            const optionsEl = document.getElementById('confirm-modal-options');
            const removeCompletedEl = document.getElementById('confirm-modal-remove-completed');
            const cancelButton = document.getElementById('confirm-modal-cancel');
            const actionButton = document.getElementById('confirm-modal-action');
            actionButton.textContent = options.actionText || 'Confirm';
            cancelButton.textContent = options.cancelText || 'Cancel';
            cancelButton.style.display = options.showCancel === false ? 'none' : '';
            if (options.showRemoveCompletedToggle) {
                optionsEl.style.display = 'block';
                const stored = localStorage.getItem(storageKeys.clearRecentlyCompleted);
                if (stored !== null) {
                    removeCompletedEl.checked = stored === 'true';
                } else {
                    removeCompletedEl.checked = options.removeCompletedDefault !== false;
                }
            } else {
                optionsEl.style.display = 'none';
                removeCompletedEl.checked = true;
            }
            document.getElementById('confirm-modal').classList.add('active');
        }

        function confirmModalChoice(title, message, options = {}) {
            return new Promise(resolve => {
                showConfirmModal(
                    title,
                    message,
                    () => resolve(true),
                    {
                        ...options,
                        onCancel: () => resolve(false),
                    }
                );
            });
        }

        function closeConfirmModal(event) {
            // If called from overlay click, only close if clicking the overlay itself
            if (event && event.target !== event.currentTarget) return;
            if (event && event.target === event.currentTarget && confirmCancelCallback) {
                confirmCancelCallback();
            }
            document.getElementById('confirm-modal').classList.remove('active');
            confirmCallback = null;
            confirmCancelCallback = null;
        }

        document.getElementById('confirm-modal-action').addEventListener('click', () => {
            if (confirmCallback) {
                confirmCallback();
            }
            closeConfirmModal();
        });

        document.getElementById('confirm-modal-cancel').addEventListener('click', () => {
            if (confirmCancelCallback) {
                confirmCancelCallback();
            }
            closeConfirmModal();
        });

        // Performance: Debounced refresh - batches multiple rapid updates
        function debouncedRefreshJobs() {
            pendingRefreshNeeded = true;
            if (refreshDebounceTimer) return; // Already scheduled

            refreshDebounceTimer = setTimeout(() => {
                refreshDebounceTimer = null;
                if (pendingRefreshNeeded) {
                    pendingRefreshNeeded = false;
                    refreshJobs();
                }
            }, REFRESH_DEBOUNCE_MS);
        }

        async function refreshJobs() {
            try {
                const resp = await fetch('/api/jobs');
                const data = await resp.json();
                updateJobs(data.jobs);
                updateStats(data.stats);
            } catch (err) {
                console.error('Refresh error:', err);
            }
        }

        // Performance: Render a single job item HTML (extracted for reuse)
        function renderJobHtml(job) {
            const filename = job.input_path.split('/').pop();
            const isInitializing = job.status === 'running' && job.progress === 0 && job.speed === 0;
            const isPendingProbe = job.status === 'pending_probe';
            const statusClass = isInitializing ? 'initializing' : (isPendingProbe ? 'pending' : job.status);
            const statusLabel = isInitializing ? 'Initializing' : (isPendingProbe ? 'Scanning' : job.status.charAt(0).toUpperCase() + job.status.slice(1));
            const canReorder = job.status === 'pending' || job.status === 'pending_probe';

            let detailsHtml = '';
            if (isPendingProbe) {
                detailsHtml = '<span class="job-detail">Waiting to scan...</span>';
            } else if (job.status === 'running') {
                const elapsed = formatElapsed(job);
                if (isInitializing) {
                    detailsHtml = '<span class="job-detail">Starting encoder...</span>';
                } else {
                    detailsHtml = renderRunningDetails(job.progress, job.speed, job.eta || '...', elapsed);
                }
            } else if (job.status === 'complete') {
                const elapsed = formatElapsed(job);
                detailsHtml = `
                    <span class="job-detail job-saved">Saved <span class="job-detail-value">${formatBytes(job.space_saved)}</span></span>
                    <span class="job-detail">${formatBytes(job.input_size)} â†’ ${formatBytes(job.output_size)}</span>
                    ${elapsed ? `<span class="job-detail">Elapsed: <span class="job-detail-value">${elapsed}</span></span>` : ''}
                `;
            }

            const safeId = escapeHtml(job.id);
            const safePath = escapeHtml(job.input_path);
            const safeFilename = escapeHtml(filename);
            const safeError = escapeHtml(job.error);

            return `
                <div class="job-item ${canReorder ? 'draggable' : ''}" data-job-id="${safeId}" ${canReorder ? 'draggable="true"' : ''}>
                    <div class="job-header">
                        <span class="job-name" title="${safePath}">${safeFilename}</span>
                        <div class="job-badges">
                            ${job.is_software_fallback ? '<span class="job-badge retry">Retry</span>' : ''}
                            <span class="job-badge ${job.is_hardware ? 'hardware' : 'software'}">${job.is_hardware ? 'HW' : 'SW'}</span>
                            <span class="job-badge ${statusClass}">${statusLabel}</span>
                        </div>
                    </div>
                    ${job.status === 'running' ? `
                        <div class="job-progress">
                            <div class="progress-bar">
                                <div class="progress-fill ${isInitializing ? 'initializing' : ''}" style="width: ${isInitializing ? 0 : job.progress}%"></div>
                            </div>
                        </div>
                    ` : ''}
                    <div class="job-details">${detailsHtml}</div>
                    ${job.status === 'failed' ? `<div class="job-error">${safeError}</div>` : ''}
                    ${job.status === 'failed' ? renderErrorHelper(job) : ''}
                    ${job.status === 'pending' || job.status === 'pending_probe' || job.status === 'running' ? `
                        <div class="job-actions">
                            ${canReorder ? `
                                <button class="btn btn-secondary btn-sm" onclick="moveJob('${safeId}', 'up')" aria-label="Move job up">â†‘</button>
                                <button class="btn btn-secondary btn-sm" onclick="moveJob('${safeId}', 'down')" aria-label="Move job down">â†“</button>
                            ` : ''}
                            <button class="btn btn-secondary btn-sm" onclick="cancelJob('${safeId}')">Cancel</button>
                        </div>
                    ` : ''}
                    ${job.status === 'failed' ? `
                        <div class="job-actions">
                            <button class="btn btn-secondary btn-sm" onclick="retryJob('${safeId}')">Retry</button>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // Performance: Handle 'added' event by appending to DOM instead of full rebuild
        function handleJobAdded(job) {
            // Add to cache
            cachedJobs.push(job);

            // Update virtual scroll state
            if (virtualScrollEnabled) {
                addJobToVirtualState(job);
            }

            // Update stats locally - handle both pending and pending_probe
            if (job.status === 'pending') cachedStats.pending++;
            else if (job.status === 'pending_probe') cachedStats.pending_probe++;
            updateStats(cachedStats);

            const container = document.getElementById('queue-list');
            if (virtualScrollEnabled) {
                // Virtual scroll: re-render if new job might be visible
                scrollContainer = container;
                if (container.querySelector('.queue-empty')) {
                    container.innerHTML = '';
                }
                updateVisibleRange();
                renderVirtualJobs();
            } else {
                // Legacy: append to DOM
                if (container.querySelector('.queue-empty')) {
                    container.innerHTML = renderJobHtml(job);
                } else {
                    container.insertAdjacentHTML('beforeend', renderJobHtml(job));
                }
            }

            updateActivePanel();
        }

        // Performance: Handle status change by updating single DOM element
        function handleJobStatusChange(job) {
            // Update in cache
            const idx = cachedJobs.findIndex(j => j.id === job.id);
            if (idx >= 0) {
                const oldStatus = cachedJobs[idx].status;
                const localStartedAt = cachedJobs[idx].local_started_at;
                cachedJobs[idx] = job;
                if (localStartedAt && !cachedJobs[idx].local_started_at) {
                    cachedJobs[idx].local_started_at = localStartedAt;
                }
                ensureLocalStartedAt(cachedJobs[idx], getStartedAtMs(cachedJobs[idx]));

                // Update virtual scroll state
                if (virtualScrollEnabled) {
                    updateJobInVirtualState(job);
                }

                // Update stats locally
                if (oldStatus !== job.status) {
                    if (oldStatus === 'pending') cachedStats.pending--;
                    if (oldStatus === 'pending_probe') cachedStats.pending_probe--;
                    if (oldStatus === 'running') cachedStats.running--;
                    if (job.status === 'pending') cachedStats.pending++;
                    if (job.status === 'pending_probe') cachedStats.pending_probe++;
                    if (job.status === 'running') cachedStats.running++;
                    if (job.status === 'complete') {
                        cachedStats.complete++;
                        cachedStats.total_saved += job.space_saved || 0;
                    }
                    if (job.status === 'failed') cachedStats.failed++;
                    updateStats(cachedStats);
                }
            }

            if (job.status !== 'failed') {
                errorHelperExpanded.delete(job.id);
                errorRawExpanded.delete(job.id);
            }

            // If job completed, move it to the completed section
            if (job.status === 'complete') {
                // Remove from main queue list
                const safeId = escapeCssSelector(job.id);
                const el = document.querySelector(`.job-item[data-job-id="${safeId}"]`);
                if (el) {
                    el.remove();
                }
                // Remove from virtual scroll state if enabled
                if (virtualScrollEnabled) {
                    removeJobFromVirtualState(job.id);
                }
                // Update completed section
                const completedJobs = cachedJobs.filter(j => j.status === 'complete');
                updateCompletedSection(completedJobs);
            } else if (virtualScrollEnabled) {
                // Virtual scroll: only update if visible
                updateJobInView(job);
            } else {
                // Legacy: find and update DOM element
                const safeId = escapeCssSelector(job.id);
                const el = document.querySelector(`.job-item[data-job-id="${safeId}"]`);
                if (el) {
                    el.outerHTML = renderJobHtml(job);
                }
            }

            updateActivePanel();
        }

        function updateJobs(jobs) {
            const container = document.getElementById('queue-list');
            cachedJobs = jobs || [];
            pruneErrorHelperState(cachedJobs);
            for (const job of cachedJobs) {
                ensureLocalStartedAt(job, getStartedAtMs(job));
            }

            // Separate completed jobs from active queue
            const completedJobs = cachedJobs.filter(j => j.status === 'complete');
            const activeJobs = cachedJobs.filter(j => j.status !== 'complete');

            // Update completed section (compact view)
            updateCompletedSection(completedJobs);

            // Update virtual scroll state (only for active jobs)
            if (virtualScrollEnabled) {
                clearVirtualState();
                for (const job of activeJobs) {
                    addJobToVirtualState(job);
                }
            }

            if (activeJobs.length === 0) {
                container.innerHTML = `
                    <div class="queue-empty">
                        <div class="queue-empty-icon">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="opacity: 0.3">
                                <rect x="3" y="3" width="18" height="18" rx="2"/>
                                <path d="M3 9h18"/>
                                <path d="M9 21V9"/>
                            </svg>
                        </div>
                        <div>No jobs in queue</div>
                        <div style="font-size: 0.8125rem; margin-top: 4px; color: var(--text-tertiary)">Select files and start transcoding</div>
                    </div>
                `;
                updateActivePanel();
                return;
            }

            if (virtualScrollEnabled) {
                // Virtual scroll: only render visible items
                scrollContainer = container;
                updateVisibleRange();
                renderVirtualJobs();
            } else {
                // Legacy: render all jobs (only active, not completed)
                container.innerHTML = activeJobs.map(job => renderJobHtml(job)).join('');
            }
            updateActivePanel();
        }

        function updateStats(stats) {
            // Cache stats for incremental updates
            cachedStats = { ...stats };
            // pending_probe jobs are shown in the pending count for UI simplicity
            const totalPending = (stats.pending || 0) + (stats.pending_probe || 0);
            document.getElementById('stat-pending').textContent = totalPending;
            document.getElementById('stat-running').textContent = stats.running;
            const saved = Math.max(0, stats.total_saved || 0);
            document.getElementById('stat-saved').textContent = formatBytes(saved);
        }

        // ========================================
        // Drag-and-drop Queue Reordering
        // ========================================

        let dragJobId = null;
        let dragScrollTimer = null;

        function getPendingOrderIds() {
            return cachedJobs
                .filter(job => job.status === 'pending' || job.status === 'pending_probe')
                .map(job => job.id);
        }

        function stopDragScroll() {
            if (dragScrollTimer) {
                clearInterval(dragScrollTimer);
                dragScrollTimer = null;
            }
        }

        function startDragScroll(container, direction) {
            if (dragScrollTimer) {
                return;
            }
            dragScrollTimer = setInterval(() => {
                container.scrollTop += direction * 18;
            }, 16);
        }

        function handleDragOver(event) {
            event.preventDefault();
            if (!dragJobId) return;

            const container = document.getElementById('queue-list');
            if (!container) return;

            const rect = container.getBoundingClientRect();
            const offset = event.clientY - rect.top;
            const edge = 48;
            if (offset < edge) {
                startDragScroll(container, -1);
            } else if (offset > rect.height - edge) {
                startDragScroll(container, 1);
            } else {
                stopDragScroll();
            }
        }

        function attachQueueDragHandlers() {
            const container = document.getElementById('queue-list');
            if (!container) return;

            container.addEventListener('dragstart', (event) => {
                const item = event.target.closest('.job-item.draggable');
                if (!item) return;
                dragJobId = item.dataset.jobId;
                item.classList.add('dragging');
                event.dataTransfer.setData('text/plain', dragJobId);
                event.dataTransfer.effectAllowed = 'move';
            });

            container.addEventListener('dragend', () => {
                stopDragScroll();
                dragJobId = null;
                container.querySelectorAll('.job-item.drag-over').forEach(el => el.classList.remove('drag-over'));
                container.querySelectorAll('.job-item.dragging').forEach(el => el.classList.remove('dragging'));
            });

            container.addEventListener('dragover', handleDragOver);

            container.addEventListener('dragenter', (event) => {
                const item = event.target.closest('.job-item.draggable');
                if (!item || item.dataset.jobId === dragJobId) return;
                item.classList.add('drag-over');
            });

            container.addEventListener('dragleave', (event) => {
                const item = event.target.closest('.job-item.draggable');
                if (!item) return;
                item.classList.remove('drag-over');
            });

            container.addEventListener('drop', (event) => {
                event.preventDefault();
                stopDragScroll();
                const targetItem = event.target.closest('.job-item.draggable');
                if (!dragJobId) return;

                const pendingIds = getPendingOrderIds();
                if (pendingIds.length === 0) return;

                if (!targetItem) {
                    moveJobTo(dragJobId, '');
                    return;
                }

                const targetId = targetItem.dataset.jobId;
                if (targetId === dragJobId) return;

                const rect = targetItem.getBoundingClientRect();
                const dropAfter = event.clientY > rect.top + rect.height / 2;
                const targetIdx = pendingIds.indexOf(targetId);
                if (targetIdx === -1) return;

                const beforeId = dropAfter ? pendingIds[targetIdx + 1] : pendingIds[targetIdx];
                moveJobTo(dragJobId, beforeId);
            });
        }

        // ========================================
        // Completed Jobs Section
        // ========================================

        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            if (!panel) {
                return;
            }

            panel.classList.toggle('collapsed');
            const toggleButton = panel.querySelector('.panel-toggle');
            if (toggleButton) {
                toggleButton.setAttribute('aria-expanded', String(!panel.classList.contains('collapsed')));
            }
        }

        function toggleCompletedSection() {
            const list = document.getElementById('completed-list');
            const toggle = document.getElementById('completed-toggle');
            const isExpanded = list.classList.contains('expanded');

            if (isExpanded) {
                list.classList.remove('expanded');
                toggle.classList.remove('expanded');
            } else {
                list.classList.add('expanded');
                toggle.classList.add('expanded');
            }
        }

        function updateCompletedSection(completedJobs) {
            const section = document.getElementById('completed-section');
            const countEl = document.getElementById('completed-count');
            const listEl = document.getElementById('completed-list');

            if (!completedJobs || completedJobs.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            countEl.textContent = completedJobs.length;

            // Show most recent 50 completed jobs (newest first)
            const recentJobs = completedJobs
                .sort((a, b) => new Date(b.completed_at) - new Date(a.completed_at))
                .slice(0, 50);

            listEl.innerHTML = recentJobs.map(job => {
                const filename = job.input_path.split('/').pop();
                const safeFilename = escapeHtml(filename);
                const savedText = job.space_saved > 0 ? formatBytes(job.space_saved) : 'â€”';
                const elapsed = formatElapsed(job);
                return `
                    <div class="completed-item">
                        <span class="completed-item-name" title="${escapeHtml(job.input_path)}">${safeFilename}</span>
                        <span class="completed-item-meta">
                            <span class="completed-item-saved">-${savedText}</span>
                            ${elapsed ? `<span class="completed-item-time">${elapsed}</span>` : ''}
                        </span>
                    </div>
                `;
            }).join('');
        }

        function updateActivePanel() {
            const panel = document.getElementById('active-panel');
            const nowProcessingContent = document.getElementById('now-processing-content');
            const upNextSection = document.getElementById('up-next-section');
            const upNextList = document.getElementById('up-next-list');

            // Performance: Use status indexes for O(1) lookup when virtual scroll is enabled
            let runningJobs, pendingJobs;
            if (virtualScrollEnabled) {
                runningJobs = getJobsByStatus('running');
                // Include both pending and pending_probe in "up next"
                const pendingIds = [...statusIndex.pending, ...statusIndex.pending_probe];
                pendingJobs = pendingIds.slice(0, 5).map(id => jobMap.get(id)).filter(Boolean);
            } else {
                // Legacy O(N) filtering
                runningJobs = cachedJobs.filter(j => j.status === 'running');
                pendingJobs = cachedJobs.filter(j => j.status === 'pending' || j.status === 'pending_probe').slice(0, 5);
            }

            // If no running jobs and no pending jobs, hide the panel
            if (runningJobs.length === 0 && pendingJobs.length === 0) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';

            // Update "Now Processing" section - render as full job items
            if (runningJobs.length > 0) {
                nowProcessingContent.innerHTML = runningJobs.map(job => {
                    const filename = job.input_path.split('/').pop();
                    const isInitializing = job.progress === 0 && job.speed === 0;
                    const statusClass = isInitializing ? 'initializing' : 'running';
                    const statusLabel = isInitializing ? 'Initializing' : 'Running';
                    const elapsed = formatElapsed(job);

                    const safeId = escapeHtml(job.id);
                    const safePath = escapeHtml(job.input_path);
                    const safeFilename = escapeHtml(filename);

                    let detailsHtml = '';
                    if (isInitializing) {
                        detailsHtml = '<span class="job-detail">Starting encoder...</span>';
                    } else {
                        detailsHtml = renderRunningDetails(
                            job.progress,
                            job.speed,
                            escapeHtml(job.eta) || '...',
                            elapsed
                        );
                    }

                    return `
                        <div class="job-item active-job-item" data-job-id="${safeId}">
                            <div class="job-header">
                                <span class="job-name" title="${safePath}">${safeFilename}</span>
                                <div class="job-badges">
                                    ${job.is_software_fallback ? '<span class="job-badge retry">Retry</span>' : ''}
                                    <span class="job-badge ${job.is_hardware ? 'hardware' : 'software'}">${job.is_hardware ? 'HW' : 'SW'}</span>
                                    <span class="job-badge ${statusClass}">${statusLabel}</span>
                                </div>
                            </div>
                            <div class="job-progress">
                                <div class="progress-bar">
                                    <div class="progress-fill ${isInitializing ? 'initializing' : ''}" style="width: ${isInitializing ? 0 : job.progress}%"></div>
                                </div>
                            </div>
                            <div class="job-details">${detailsHtml}</div>
                            <div class="job-actions">
                                <button class="btn btn-secondary btn-sm" onclick="cancelJob('${safeId}')">Cancel</button>
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                nowProcessingContent.innerHTML = '<div class="active-panel-empty">No active job</div>';
            }

            // Update "Up Next" section - render as full job items (pending style)
            if (pendingJobs.length > 0) {
                upNextSection.style.display = 'block';
                upNextList.innerHTML = pendingJobs.map(job => {
                    const filename = job.input_path.split('/').pop();
                    const safeId = escapeHtml(job.id);
                    const safePath = escapeHtml(job.input_path);
                    const safeFilename = escapeHtml(filename);
                    const safePreset = escapeHtml(job.preset_id || 'default');

                    return `
                        <div class="job-item" data-job-id="${safeId}">
                            <div class="job-header">
                                <span class="job-name" title="${safePath}">${safeFilename}</span>
                                <div class="job-badges">
                                    ${job.is_software_fallback ? '<span class="job-badge retry">Retry</span>' : ''}
                                    <span class="job-badge ${job.is_hardware ? 'hardware' : 'software'}">${job.is_hardware ? 'HW' : 'SW'}</span>
                                    <span class="job-badge pending">Pending</span>
                                </div>
                            </div>
                            <div class="job-details">
                                <span class="job-detail">Preset: <span class="job-detail-value">${safePreset}</span></span>
                                <span class="job-detail">${formatBytes(job.input_size)}</span>
                            </div>
                            <div class="job-actions">
                                <button class="btn btn-secondary btn-sm" onclick="cancelJob('${safeId}')">Cancel</button>
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                upNextSection.style.display = 'none';
            }
        }

        // Targeted update for progress events only - avoids full DOM rebuild
        function updateActiveJobProgress(jobData) {
            const isInitializing = jobData.progress === 0 && jobData.speed === 0;
            const safeEta = escapeHtml(jobData.eta) || '...';
            const cachedJob = cachedJobs.find(j => j.id === jobData.id);
            if (cachedJob) {
                cachedJob.progress = jobData.progress;
                cachedJob.speed = jobData.speed;
                cachedJob.eta = jobData.eta;
                ensureLocalStartedAt(cachedJob, getStartedAtMs(cachedJob));
            }
            const elapsed = formatElapsed(cachedJob || jobData);

            updateCachedJobProgress(jobData.id, jobData.progress, jobData.speed, jobData.eta);

            // Update active panel - find the specific job item by ID
            const nowProcessingContent = document.getElementById('now-processing-content');
            const safeId = escapeCssSelector(jobData.id);
            const activeJobEl = nowProcessingContent ? nowProcessingContent.querySelector(`.active-job-item[data-job-id="${safeId}"]`) : null;

            // If active job element doesn't exist yet, fall back to full refresh
            if (!activeJobEl) {
                refreshJobs();
                return;
            }

            // Update progress bar in active panel
            const activeFill = activeJobEl.querySelector('.progress-fill');
            if (activeFill) {
                activeFill.style.width = (isInitializing ? 0 : jobData.progress) + '%';
                activeFill.className = 'progress-fill' + (isInitializing ? ' initializing' : '');
            }

            // Update details in active panel
            const activeDetails = activeJobEl.querySelector('.job-details');
            if (activeDetails) {
                if (isInitializing) {
                    activeDetails.innerHTML = '<span class="job-detail">Starting encoder...</span>';
                } else {
                    updateRunningDetails(activeDetails, jobData.progress, jobData.speed, safeEta, elapsed);
                }
            }

            // Update status badge in active panel
            const activeBadge = activeJobEl.querySelector('.job-badge.running, .job-badge.initializing');
            if (activeBadge) {
                activeBadge.className = 'job-badge ' + (isInitializing ? 'initializing' : 'running');
                activeBadge.textContent = isInitializing ? 'Initializing' : 'Running';
            }

            // Update the corresponding row in the queue list (use escaped selector)
            const queueList = document.getElementById('queue-list');
            const safeSelector = `.job-item[data-job-id="${escapeCssSelector(jobData.id)}"]`;
            const queueRow = queueList ? queueList.querySelector(safeSelector) : null;
            if (queueRow) {
                // Update progress bar
                const progressFill = queueRow.querySelector('.progress-fill');
                if (progressFill) {
                    progressFill.style.width = (isInitializing ? 0 : jobData.progress) + '%';
                    progressFill.className = 'progress-fill' + (isInitializing ? ' initializing' : '');
                }

                // Update details
            const detailsEl = queueRow.querySelector('.job-details');
            if (detailsEl) {
                if (isInitializing) {
                    detailsEl.innerHTML = '<span class="job-detail">Starting encoder...</span>';
                } else {
                    updateRunningDetails(detailsEl, jobData.progress, jobData.speed, safeEta, elapsed);
                }
            }

                // Update status badge
                const statusBadge = queueRow.querySelector('.job-badge.running, .job-badge.initializing');
                if (statusBadge) {
                    statusBadge.className = 'job-badge ' + (isInitializing ? 'initializing' : 'running');
                    statusBadge.textContent = isInitializing ? 'Initializing' : 'Running';
                }
            }
        }

        // Update cached job data already handled above
        

        // Performance: Handle batch of jobs added at once
        // This is called when AddMultiple() sends a single "batch_added" event
        // instead of N individual "added" events
        function handleBatchAdded(jobs) {
            if (!jobs || jobs.length === 0) return;

            // Add all jobs to cache and virtual scroll state
            for (const job of jobs) {
                cachedJobs.push(job);
                if (virtualScrollEnabled) {
                    addJobToVirtualState(job);
                }
            }

            // Update stats - handle both pending and pending_probe
            for (const job of jobs) {
                if (job.status === 'pending') cachedStats.pending++;
                else if (job.status === 'pending_probe') cachedStats.pending_probe++;
            }
            updateStats(cachedStats);

            const container = document.getElementById('queue-list');
            if (virtualScrollEnabled) {
                // Virtual scroll: re-render visible range
                scrollContainer = container;
                if (container.querySelector('.queue-empty')) {
                    container.innerHTML = '';
                }
                updateVisibleRange();
                renderVirtualJobs();
            } else {
                // Legacy: render all jobs to DOM in a single operation
                if (container.querySelector('.queue-empty')) {
                    container.innerHTML = jobs.map(job => renderJobHtml(job)).join('');
                } else {
                    const fragment = jobs.map(job => renderJobHtml(job)).join('');
                    container.insertAdjacentHTML('beforeend', fragment);
                }
            }

            updateActivePanel();
        }

        // Performance: Handle delta progress updates (compact payload)
        // Only contains: id, progress, speed, eta
        function handleProgressDelta(update) {
            const { id, progress, speed, eta } = update;
            const isInitializing = progress === 0 && speed === 0;
            const safeEta = escapeHtml(eta) || '...';

            // Update cached job
            const cachedJob = cachedJobs.find(j => j.id === id);
            if (cachedJob) {
                cachedJob.progress = progress;
                cachedJob.speed = speed;
                cachedJob.eta = eta;
                ensureLocalStartedAt(cachedJob, getStartedAtMs(cachedJob));
            }
            const elapsed = formatElapsed(cachedJob);

            // Update active panel job
            const safeId = escapeCssSelector(id);
            const activeJobEl = document.querySelector(`#now-processing-content .active-job-item[data-job-id="${safeId}"]`);

            if (activeJobEl) {
                // Update progress bar
                const activeFill = activeJobEl.querySelector('.progress-fill');
                if (activeFill) {
                    activeFill.style.width = (isInitializing ? 0 : progress) + '%';
                    activeFill.className = 'progress-fill' + (isInitializing ? ' initializing' : '');
                }

                // Update details
            const activeDetails = activeJobEl.querySelector('.job-details');
            if (activeDetails) {
                if (isInitializing) {
                    activeDetails.innerHTML = '<span class="job-detail">Starting encoder...</span>';
                } else {
                    updateRunningDetails(activeDetails, progress, speed, safeEta, elapsed);
                }
            }

                // Update status badge
                const activeBadge = activeJobEl.querySelector('.job-badge.running, .job-badge.initializing');
                if (activeBadge) {
                    activeBadge.className = 'job-badge ' + (isInitializing ? 'initializing' : 'running');
                    activeBadge.textContent = isInitializing ? 'Initializing' : 'Running';
                }
            }

            // Update queue list row
            const queueList = document.getElementById('queue-list');
            const queueRow = queueList ? queueList.querySelector(`.job-item[data-job-id="${safeId}"]`) : null;
            if (queueRow) {
                const progressFill = queueRow.querySelector('.progress-fill');
                if (progressFill) {
                    progressFill.style.width = (isInitializing ? 0 : progress) + '%';
                    progressFill.className = 'progress-fill' + (isInitializing ? ' initializing' : '');
                }

            const detailsEl = queueRow.querySelector('.job-details');
            if (detailsEl) {
                if (isInitializing) {
                    detailsEl.innerHTML = '<span class="job-detail">Starting encoder...</span>';
                } else {
                    updateRunningDetails(detailsEl, progress, speed, safeEta, elapsed);
                }
            }

                const statusBadge = queueRow.querySelector('.job-badge.running, .job-badge.initializing');
                if (statusBadge) {
                    statusBadge.className = 'job-badge ' + (isInitializing ? 'initializing' : 'running');
                    statusBadge.textContent = isInitializing ? 'Initializing' : 'Running';
                }
            }
        }

        function connectSSE() {
            if (eventSource) eventSource.close();

            eventSource = new EventSource('/api/jobs/stream');

            eventSource.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.type === 'init') {
                    updateJobs(data.jobs);
                    updateStats(data.stats);
                } else if (data.type === 'notify_sent') {
                    // Notification was sent, uncheck the checkbox
                    document.getElementById('notify-checkbox').checked = false;
                    localStorage.setItem(storageKeys.notifyOnComplete, 'false');
                } else if (data.type === 'batch_added' && data.jobs) {
                    // Performance: Handle batch of jobs in single DOM operation
                    handleBatchAdded(data.jobs);
                } else if (data.type === 'progress') {
                    // Performance: Handle progress updates
                    if (data.progress_update) {
                        // New delta format (compact payload)
                        handleProgressDelta(data.progress_update);
                    } else if (data.job) {
                        // Legacy full job format (backwards compatibility)
                        updateActiveJobProgress(data.job);
                    }
                } else if (data.type === 'added' && data.job) {
                    // Single job added (backwards compatibility)
                    handleJobAdded(data.job);
                } else if (data.type === 'probed' && data.job) {
                    // Job probed: pending_probe â†’ pending, update with probe data
                    handleJobStatusChange(data.job);
                } else if ((data.type === 'started' || data.type === 'complete' || data.type === 'failed' || data.type === 'cancelled') && data.job) {
                    // Performance: Update single job instead of full refresh
                    handleJobStatusChange(data.job);
                    if (data.type === 'complete' || data.type === 'failed') {
                        // Refresh file list to update metadata, but preserve selections
                        browse(currentPath, true, { updateHistory: false });
                    }
                } else {
                    // Fallback: debounced full refresh for unknown event types
                    debouncedRefreshJobs();
                }
            };

            eventSource.onerror = () => {
                setTimeout(connectSSE, 2000);
            };
        }

        // Settings
        function openSettings() {
            document.getElementById('settings-overlay').classList.add('open');
        }

        function closeSettings(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('settings-overlay').classList.remove('open');
        }

        async function loadSettings() {
            try {
                const resp = await fetch('/api/config');
                const config = await resp.json();

                // Display version
                if (config.version) {
                    document.getElementById('app-version').textContent = config.version;
                }

                document.getElementById('setting-original-handling').value = config.original_handling || 'replace';
                document.getElementById('setting-workers').value = config.workers || 1;

                // Pushover settings
                document.getElementById('setting-pushover-user').value = config.pushover_user_key || '';
                document.getElementById('setting-pushover-token').value = config.pushover_app_token || '';

                // ntfy settings
                document.getElementById('setting-ntfy-server').value = config.ntfy_server || '';
                document.getElementById('setting-ntfy-topic').value = config.ntfy_topic || '';
                document.getElementById('setting-ntfy-token').value = config.ntfy_token || '';

                document.getElementById('setting-hide-processing-tmp').checked = config.hide_processing_tmp || false;

                // Show/hide notify checkbox based on whether any provider is configured
                const notifyContainer = document.getElementById('notify-container');
                const notifyCheckbox = document.getElementById('notify-checkbox');
                if (config.pushover_configured || config.ntfy_configured) {
                    notifyContainer.style.display = 'flex';
                    const storedNotify = localStorage.getItem(storageKeys.notifyOnComplete);
                    const notifyValue = storedNotify !== null ? storedNotify === 'true' : (config.notify_on_complete || false);
                    notifyCheckbox.checked = notifyValue;
                    if (notifyValue !== (config.notify_on_complete || false)) {
                        updateNotifySetting(notifyValue);
                    }
                } else {
                    notifyContainer.style.display = 'none';
                }

                // ðŸ¦„ Unicorn Mode (stored locally, not in config)
                const unicornEnabled = localStorage.getItem('shrinkray-unicorn') === 'true';
                document.getElementById('setting-unicorn-mode').checked = unicornEnabled;
                updateStartButtonText();

                // Feature flags - initialize virtual scrolling if enabled
                if (config.features) {
                    if (config.features.virtual_scroll && !virtualScrollEnabled) {
                        virtualScrollEnabled = true;
                        console.log('[perf] Virtual scrolling enabled via feature flag');
                        initVirtualScroll();
                    }
                }
            } catch (err) {
                console.error('Load settings error:', err);
            }
        }

        async function updateSetting(key, value) {
            const statusEl = document.getElementById('settings-status');
            try {
                const body = {};
                body[key] = value;

                const resp = await fetch('/api/config', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                if (!resp.ok) {
                    const data = await resp.json();
                    throw new Error(data.error || 'Failed to update');
                }

                statusEl.textContent = 'Settings saved';
                statusEl.className = 'settings-status';
                setTimeout(() => { statusEl.textContent = ''; }, 2000);

                // Reload settings to update notify checkbox visibility
                if (key === 'pushover_user_key' || key === 'pushover_app_token' || key === 'ntfy_server' || key === 'ntfy_topic' || key === 'ntfy_token') {
                    loadSettings();
                }
                return true;
            } catch (err) {
                statusEl.textContent = `Error: ${err.message}`;
                statusEl.className = 'settings-status error';
                return false;
            }
        }

        async function toggleHideProcessingTmp(enabled) {
            const updated = await updateSetting('hide_processing_tmp', enabled);
            if (updated) {
                browse(currentPath, false, { updateHistory: false });
            }
        }

        async function clearProcessedHistory() {
            const statusEl = document.getElementById('settings-status');
            const confirmed = window.confirm('Clear processed history? This will reset processed badges and counts.');
            if (!confirmed) {
                return;
            }

            try {
                const resp = await fetch('/api/processed/clear', { method: 'POST' });
                const data = await resp.json();

                if (!resp.ok) {
                    throw new Error(data.error || 'Failed to clear processed history');
                }

                statusEl.textContent = data.message || 'Processed history cleared';
                statusEl.className = 'settings-status';
                setTimeout(() => { statusEl.textContent = ''; }, 2000);

                browse(currentPath, true, { updateHistory: false });
            } catch (err) {
                statusEl.textContent = `Error: ${err.message}`;
                statusEl.className = 'settings-status error';
            }
        }

        async function updateNotifySetting(checked) {
            localStorage.setItem(storageKeys.notifyOnComplete, String(checked));
            try {
                await fetch('/api/config', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ notify_on_complete: checked })
                });
            } catch (err) {
                console.error('Update notify setting error:', err);
            }
        }

        async function testPushover() {
            const btn = document.getElementById('test-pushover-btn');
            const statusEl = document.getElementById('settings-status');
            btn.disabled = true;
            btn.textContent = 'Sending...';

            try {
                const resp = await fetch('/api/pushover/test', { method: 'POST' });
                const data = await resp.json();

                if (!resp.ok) {
                    throw new Error(data.error || 'Failed to send test');
                }

                statusEl.textContent = 'Test notification sent!';
                statusEl.className = 'settings-status';
                setTimeout(() => { statusEl.textContent = ''; }, 3000);
            } catch (err) {
                statusEl.textContent = `Error: ${err.message}`;
                statusEl.className = 'settings-status error';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Test';
            }
        }

        async function testNtfy() {
            const btn = document.getElementById('test-ntfy-btn');
            const statusEl = document.getElementById('settings-status');
            btn.disabled = true;
            btn.textContent = 'Sending...';

            try {
                const resp = await fetch('/api/ntfy/test', { method: 'POST' });
                const data = await resp.json();

                if (!resp.ok) {
                    throw new Error(data.error || 'Failed to send test');
                }

                statusEl.textContent = 'Test notification sent!';
                statusEl.className = 'settings-status';
                setTimeout(() => { statusEl.textContent = ''; }, 3000);
            } catch (err) {
                statusEl.textContent = `Error: ${err.message}`;
                statusEl.className = 'settings-status error';
            } finally {
                btn.disabled = false;
                btn.textContent = 'Test';
            }
        }

        async function loadPresets() {
            try {
                const presets = await fetch('/api/presets').then(r => r.json());
                const select = document.getElementById('preset-select');
                select.innerHTML = presets.map(p =>
                    `<option value="${p.id}">${p.name}</option>`
                ).join('');
                if (preferredPresetId && presets.some(p => p.id === preferredPresetId)) {
                    select.value = preferredPresetId;
                }
            } catch (err) {
                console.error('Load presets error:', err);
            }
        }

        function loadLocalPreferences() {
            const storedSort = localStorage.getItem(storageKeys.fileSort);
            const storedFilter = localStorage.getItem(storageKeys.fileFilter);
            const storedHideEmptyFolders = localStorage.getItem(storageKeys.hideEmptyFolders);

            if (storedSort) {
                fileListState.sort = storedSort;
                document.getElementById('file-sort').value = storedSort;
            }

            if (storedFilter) {
                fileListState.filter = storedFilter;
                document.getElementById('file-filter').value = storedFilter;
            }

            if (storedHideEmptyFolders !== null) {
                fileListState.hideEmptyFolders = storedHideEmptyFolders === 'true';
            }

            const includeSubfolders = localStorage.getItem(storageKeys.includeSubfolders);
            if (includeSubfolders !== null) {
                document.getElementById('include-subfolders').checked = includeSubfolders === 'true';
            }

            updateEmptyFolderToggleVisibility();
        }

        function bindPreferenceHandlers() {
            document.getElementById('include-subfolders').addEventListener('change', (event) => {
                localStorage.setItem(storageKeys.includeSubfolders, String(event.target.checked));
            });

            document.getElementById('confirm-modal-remove-completed').addEventListener('change', (event) => {
                localStorage.setItem(storageKeys.clearRecentlyCompleted, String(event.target.checked));
            });
        }

        function getPathFromLocation() {
            const url = new URL(window.location.href);
            return url.searchParams.get('path') || '';
        }

        // Keyboard shortcut for settings
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeSettings();
            }
        });

        // Initialize
        loadLocalPreferences();
        bindPreferenceHandlers();
        const initialPath = getPathFromLocation();
        history.replaceState({ path: initialPath }, '', window.location.href);
        browse(initialPath, false, { updateHistory: false });
        attachQueueDragHandlers();
        connectSSE();
        loadSettings();
        loadPresets();

        window.addEventListener('popstate', (event) => {
            const statePath = event.state?.path ?? getPathFromLocation();
            browse(statePath, false, { updateHistory: false });
        });
    </script>
</body>
</html>
